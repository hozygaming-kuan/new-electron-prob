Project Context:


--- START OF FILE: package.json ---
{
  "name": "my-slot-machine---template-vue-ts",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "chcp 65001 && vite",
    "build": "vue-tsc && vite build && electron-builder",
    "preview": "vite preview"
  },
  "build": {
    "appId": "slotGame",
    "extraResources": [
      {
        "from": "electron/rand-core",
        "to": "rand-core"
      },
      {
        "from": "electron/setting",
        "to": "setting"
      }
    ]
  },
  "dependencies": {
    "adm-zip": "^0.5.16",
    "folder-hash": "^4.1.1",
    "fs-extra": "^11.3.3",
    "moment": "^2.30.1",
    "numeral": "^2.0.6",
    "vue": "^3.4.21",
    "workerpool": "^10.0.1",
    "xlsjs": "^1.0.1",
    "xlsx": "^0.18.5"
  },
  "devDependencies": {
    "@types/adm-zip": "^0.5.7",
    "@types/fs-extra": "^11.0.4",
    "@types/workerpool": "^6.4.7",
    "@vitejs/plugin-vue": "^5.0.4",
    "electron": "^30.0.1",
    "electron-builder": "^24.13.3",
    "typescript": "^5.2.2",
    "vite": "^5.1.6",
    "vite-plugin-electron": "^0.28.6",
    "vite-plugin-electron-renderer": "^0.14.5",
    "vue-tsc": "^2.0.26"
  },
  "main": "dist-electron/main.js"
}

--- END OF FILE: package.json ---

--- START OF FILE: src\App.vue ---
<script setup lang="ts">
import SlotMachine from "./components/SlotMachine.vue";
import { useSlotGame } from "./composables/useSlotGame";
import ProgressWindow from './components/ProgressWindow.vue'; // ğŸ”¥ å¼•å…¥
import ReportWindow from './components/ReportWindow.vue'; // ğŸ”¥ å¼•å…¥æ–°å…ƒä»¶
import { computed, onMounted } from "vue";
import "./styles/dashboard.css";
import "./styles/report.css";
const {
  logs,
  stats,
  config,
  currentGrid,
  isSpinning,
  handleSpin,
  winningCells,
  currentWin,
  betLevels,
  currentBetIndex,
  currentBetAmount,
  spinHistory,
  currentFrameIndex,
  switchFrame,
  formatAmount,
  showDetails,
  modeOptions,
  selectedExcelFile,
  openFile,
  excelFiles,
  roundOptions,
  isDarkMode,
  toggleTheme,
  handleReload,
  handleExport,
  exportOptions,
  handleModeChange,
  onLightningClick
} = useSlotGame();

const pageType = computed(() => {
  // æ”¯æ´ ?type=report å’Œ ?type=progressï¼Œæˆ–è€…æ˜¯ hash æ¨¡å¼
  if (window.location.hash.includes('report')) return 'report';
  if (window.location.hash.includes('progress')) return 'progress'; // ğŸ”¥ æ–°å¢
  return 'dashboard';
});

onMounted(() => {
  // ç›£è½å¾Œç«¯å‚³ä¾†çš„æ¨™é¡Œæ›´æ–°äº‹ä»¶
  window.ipcRenderer.on("sys:update-title", (_event, newTitle) => {
    console.log("[System] Updating title to:", newTitle);
    document.title = newTitle as string; // ä¿®æ”¹ç¶²é æ¨™é¡Œ
  });
});
</script>

<template>

 <ReportWindow v-if="pageType === 'report'" />

  <ProgressWindow v-else-if="pageType === 'progress'" />

  <div v-else class="dashboard-container">
    <aside class="panel left-panel">
      <div class="panel-header">
        <h3 class="panel-title">Results</h3>
        <div class="header-tools">
          <label class="checkbox-label"
            ><input type="checkbox" v-model="showDetails" /> details</label
          >
          <button class="btn-xs" @click="logs = []">Clear</button>
        </div>
      </div>
      <div class="log-content custom-scrollbar">
        <div v-for="log in logs" :key="log.id" class="log-group">
          <div class="log-title" @click="log.isExpanded = !log.isExpanded">
            <span class="toggle-icon">{{ log.isExpanded ? "â–¼" : "â–¶" }}</span>
            {{ log.title }}
          </div>
          <div v-if="log.isExpanded" class="log-details">
            <div
              v-for="(detail, dIdx) in log.details"
              :key="dIdx"
              class="log-detail-item"
              :class="detail.type"
              v-show="detail.type === 'sub' || showDetails"
            >
              {{ detail.text }}
            </div>
          </div>
        </div>
      </div>
    </aside>

    <main class="panel center-panel">
      <div class="stats-container">
        <table class="stats-table">
          <tbody>
            <tr>
              <td>Total Spin</td>
              <td>{{ stats.totalSpin }}</td>
            </tr>
            <tr>
              <td>Total Bet</td>
              <td>{{ stats.totalBet }}</td>
            </tr>
            <tr>
              <td>Total Win</td>
              <td>{{ formatAmount(stats.totalWin) }}</td>
            </tr>
            <tr>
              <td>RTP</td>
              <td>{{ stats.rtp }}</td>
            </tr>
            <tr>
              <td>Total CashIn</td>
              <td>{{ stats.totalCashIn }}</td>
            </tr>
          </tbody>
        </table>
      </div>
      <div class="balance-bar">
        <span class="balance-label">Balance:</span>
        <span class="balance-value"
          >${{
            formatAmount(stats.totalCashIn + stats.totalWin - stats.totalBet)
          }}</span
        >
        <span class="win-tag" v-if="currentWin > 0"
          >(+{{ formatAmount(currentWin) }})</span
        >
      </div>
      <div class="game-area-wrapper">
        <div class="game-area">
          <SlotMachine
            :reel-data="currentGrid"
            :is-spinning="isSpinning"
            :winning-cells="winningCells"
          />
        </div>
        <div class="frame-navigation">
          <button
            v-for="(frame, idx) in spinHistory"
            :key="idx"
            class="frame-btn"
            :class="{ active: currentFrameIndex === idx }"
            @click="switchFrame(idx)"
          >
            {{ frame.label }}
          </button>
        </div>
      </div>
      <div class="bottom-controls">
        <div class="bet-control-group">
          <button
            class="btn-square"
            :disabled="isSpinning || currentBetIndex <= 0"
            @click="currentBetIndex--"
          >
            -
          </button>
          <div class="bet-display">
            <div class="label">BET</div>
            <div class="value">{{ currentBetAmount }}</div>
          </div>
          <button
            class="btn-square"
            :disabled="isSpinning || currentBetIndex >= betLevels.length - 1"
            @click="currentBetIndex++"
          >
            +
          </button>
        </div>
        <div class="win-display">
          <div class="label">WIN</div>
          <div class="value">{{ formatAmount(currentWin) }}</div>
        </div>
        <button class="btn-spin" @click="handleSpin" :disabled="isSpinning">
          {{ isSpinning ? "..." : "SPIN" }}
        </button>
      </div>
    </main>

    <aside class="panel right-panel custom-scrollbar">
      <div class="panel-section control-card">
        <div
          class="card-header"
          style="
            display: flex;
            justify-content: space-between;
            align-items: center;
          "
        >
          <span class="card-title">System Actions</span>
          <button
            class="theme-toggle-btn"
            @click="toggleTheme"
            :title="isDarkMode ? 'Switch to Light Mode' : 'Switch to Dark Mode'"
          >
            {{ isDarkMode ? "ğŸŒ™" : "â˜€ï¸" }}
          </button>
        </div>

        <div
          class="card-body py-2"
          style="display: flex; flex-direction: column"
        >
          <div class="system-compact-row">
            <div class="compact-switch-group">
              <span class="switch-label">Zip</span>
              <label class="toggle-switch small">
                <input type="checkbox" v-model="exportOptions.useZip" />
                <span class="slider"></span>
              </label>
            </div>

            <div class="compact-switch-group">
              <span class="switch-label">Xls</span>
              <label class="toggle-switch small">
                <input type="checkbox" v-model="exportOptions.exportSource" />
                <span class="slider"></span>
              </label>
            </div>

            <button
              class="btn-primary btn-sm"
              style="flex: 1"
              @click="handleReload"
            >
              Reload
            </button>
            <button
              class="btn-secondary btn-sm"
              style="flex: 1"
              @click="handleExport"
            >
              Export
            </button>
          </div>
        </div>
      </div>

      <div class="panel-section control-card">
        <div class="card-header py-1">
          <span class="card-title">Excel Configs</span>
        </div>
        <div class="card-body py-2">
          <div class="quick-btns">
            <button
              class="btn-secondary btn-block btn-sm"
              @click="openFile('define.xls')"
            >
              Define
            </button>
            <button
              class="btn-secondary btn-block btn-sm"
              @click="openFile('default/plate_990.xls')"
            >
              Plate
            </button>
          </div>
          <div class="dropdown-row mt-1">
            <select v-model="selectedExcelFile" class="custom-select select-sm">
              <option value="" disabled>Select Config...</option>
              <option v-for="file in excelFiles" :key="file" :value="file">
                {{ file }}
              </option>
            </select>
            <button
              class="btn-action btn-sm-action"
              @click="openFile(selectedExcelFile)"
              :disabled="!selectedExcelFile"
            >
              Open
            </button>
          </div>
        </div>
      </div>

      <div class="panel-section control-card">
        <div class="card-header py-1">
          <span class="card-title">Control</span>
        </div>
        <div class="card-body py-2">
          <div class="grid-2-col">
            <div class="input-group">
              <label>RTP Setting</label>
              <input
                v-model="config.rtpSetting"
                type="number"
                step="0.001"
                class="custom-input input-sm"
              />
            </div>
            <div class="input-group">
              <label>Max Win</label>
              <input
                v-model="config.maxWin"
                type="number"
                class="custom-input input-sm"
              />
            </div>
          </div>
        </div>
      </div>

      <div class="panel-section control-card">
        <div class="card-header py-1">
          <span class="card-title">Prizes Or BuyFeature</span>
        </div>
        <div class="card-body py-2">
          <div class="mode-btn-group">
            <button
              v-for="mode in modeOptions"
              :key="mode.value"
              class="mode-btn"
              :class="{
                active:
                  config.selectedMode === mode.value &&
                  config.modeType === mode.type,
              }"
              @click="handleModeChange(mode.value, mode.type)"
            >
              {{ mode.label }}
            </button>
          </div>
        </div>
      </div>

      <div class="panel-section control-card">
        <div class="card-header py-1">
          <span class="card-title">Volatility</span>
        </div>
        <div class="card-body py-2" style="gap: 5px">
          <div class="input-row dense">
            <input
              v-model="config.volatility"
              type="number"
              class="custom-input input-sm"
            />
            <span class="suffix-label">bring</span>
          </div>
          <div class="input-row dense">
            <input
              v-model="config.takeProfit"
              type="number"
              class="custom-input input-sm"
            />
            <span class="suffix-label">take profit</span>
          </div>
          <div class="input-row dense">
            <input
              v-model="config.stopLoss"
              type="number"
              class="custom-input input-sm"
            />
            <span class="suffix-label">limit</span>
          </div>
        </div>
      </div>

      <div class="panel-section" style="flex-direction: row; gap: 5px">
        <select
          v-model="config.rounds"
          class="custom-select select-sm"
          style="flex: 1"
        >
          <option v-for="r in roundOptions" :key="r" :value="r">
            {{ r.toLocaleString() }}
          </option>
        </select>

        <button
          class="btn-lightning btn-sm"
          style="flex: 1"
          @click="onLightningClick"
        >
          âš¡ Lighting
        </button>
      </div>
    </aside>
  </div>
</template>

--- END OF FILE: src\App.vue ---

--- START OF FILE: src\components\ProgressWindow.vue ---
<template>
  <div class="progress-window">
    <div class="title-bar">
      <span>âš¡ æ¨¡æ“¬é€²è¡Œä¸­...</span>
      <div class="window-controls">
        <button class="control-btn min-btn no-drag" @click="minimizeWindow">
          â”€
        </button>
        <button class="control-btn close-btn no-drag" @click="stopAndClose">
          Ã—
        </button>
      </div>
    </div>

    <div class="content-body">
      <div class="spinner">
        <img
          src="../assets/imgs/fastLoading.gif"
          class="spinner-img"
          alt="loading"
        />
      </div>

      <div class="progress-info">
        <span class="progress-text">{{ progress.toFixed(2) }}%</span>
      </div>

      <div class="progress-bar-track">
        <div class="progress-bar-fill" :style="{ width: progress + '%' }"></div>
      </div>

      <button class="btn-stop no-drag" @click="stopAndClose">
        ğŸ›‘ åœæ­¢æ¨¡æ“¬
      </button>

      <div v-if="error" class="error-msg">{{ error }}</div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted, onUnmounted } from "vue";

const progress = ref(0);
const currentDone = ref(0);
const totalSpins = ref(0);
const error = ref("");

// ç›£è½å¾Œç«¯å‚³ä¾†çš„é€²åº¦
const onProgress = (_event: any, payload: any) => {
  progress.value = payload.percentage;
  currentDone.value = payload.totalDone;
  totalSpins.value = payload.totalSpins;
};

// åœæ­¢ä¸¦é—œé–‰
const stopAndClose = async () => {
  await window.ipcRenderer.invoke("game:stop-lightning");
  // è¦–çª—æœƒç”±å¾Œç«¯é—œé–‰ï¼Œæˆ–è€…æˆ‘å€‘å¯ä»¥è‡ªå·±é—œ
  window.close();
};

const minimizeWindow = () => {
  window.ipcRenderer.invoke("window:minimize-progress");
};

onMounted(() => {
  // ç¶å®šç›£è½
  window.ipcRenderer.on("sys:sim-progress", onProgress);
});

onUnmounted(() => {
  window.ipcRenderer.off("sys:sim-progress", onProgress);
});
</script>

<style scoped>
.progress-window {
  display: flex;
  flex-direction: column;
  height: 100vh; /* ä½”æ»¿æ•´å€‹å°è¦–çª— */
  background: var(--bg-panel);
  border: 1px solid var(--accent-blue); /* åŠ å€‹æ˜é¡¯é‚Šæ¡† */
  color: var(--text-primary);
  user-select: none;
}

.window-controls {
  display: flex;
  gap: 0; /* æŒ‰éˆ•ç·Šè²¼ */
  height: 100%;
  align-items: center;
}

.control-btn {
  background: transparent;
  border: none;
  color: var(--text-secondary);
  font-size: 16px;
  cursor: pointer;
  height: 32px; /* è·Ÿæ¨™é¡Œåˆ—ä¸€æ¨£é«˜ */
  width: 40px; /* å¯¬ä¸€é»æ¯”è¼ƒå¥½é» */
  display: flex;
  align-items: center;
  justify-content: center;
  transition:
    background 0.2s,
    color 0.2s;
  outline: none;
}

/* æœ€å°åŒ–æŒ‰éˆ• hover */
.min-btn:hover {
  background: var(--bg-hover);
  color: var(--text-primary);
}

/* é—œé–‰æŒ‰éˆ• hover (é€šå¸¸æ˜¯ç´…è‰²) */
.close-btn:hover {
  background: #c42b1c;
  color: white;
}

/* ğŸ”¥ğŸ”¥ğŸ”¥ é—œéµ CSSï¼šè¨­å®šæ­¤å€åŸŸå¯æ‹–ç§»æ•´å€‹è¦–çª— ğŸ”¥ğŸ”¥ğŸ”¥ */
.title-bar {
  -webkit-app-region: drag;
  background: var(--bg-panel-header);
  padding: 8px 12px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-weight: bold;
  cursor: move;
}

/* ğŸ”¥ğŸ”¥ğŸ”¥ é—œéµ CSSï¼šæŒ‰éˆ•å¿…é ˆè¨­ç‚º no-dragï¼Œå¦å‰‡ç„¡æ³•é»æ“Š ğŸ”¥ğŸ”¥ğŸ”¥ */
.no-drag {
  -webkit-app-region: no-drag;
}

.content-body {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 20px;
  gap: 15px;
}

/* ... å¾©ç”¨ä¹‹å‰çš„ Spinner, Bar æ¨£å¼ ... */
.progress-bar-track {
  width: 100%;
  height: 8px;
  background: #333;
  border-radius: 4px;
  overflow: hidden;
}
.progress-bar-fill {
  height: 100%;
  background: linear-gradient(90deg, #4caf50, #8bc34a);
  transition: width 0.1s linear;
}
.spinner-img {
  /* æ ¹æ“šä½ çš„åœ–ç‰‡å¯¦éš›å¤§å°èª¿æ•´å¯¬åº¦ï¼Œé€™è£¡å…ˆæŠ“å€‹å¤§æ¦‚ */
  width: 80px;
  height: auto;

  /* é€šå¸¸ GIF æœ¬èº«å°±æœƒå‹•ï¼Œæ‰€ä»¥ä¸éœ€è¦é¡å¤–çš„ CSS å‹•ç•« */
  /* å¦‚æœè¦ºå¾—å¤ªè²¼è¿‘ä¸Šé¢ï¼Œå¯ä»¥åŠ ä¸€é» margin */
  margin-bottom: 10px;
}
.btn-stop {
  background: #d32f2f;
  color: white;
  border: none;
  padding: 5px 15px;
  border-radius: 4px;
  cursor: pointer;
}
.close-btn {
  background: none;
  border: none;
  color: #fff;
  font-size: 20px;
  cursor: pointer;
}
</style>

--- END OF FILE: src\components\ProgressWindow.vue ---

--- START OF FILE: src\components\reports\BaseReportView.vue ---
<script setup lang="ts">
import { computed, reactive } from 'vue';
import { useReportUtils } from '../../composables/useReportUtils'; // å¼•å…¥å…±ç”¨é‚è¼¯

const props = defineProps<{ data: any }>();

// ä½¿ç”¨å…±ç”¨å·¥å…·
const { fmt, safeDiv } = useReportUtils();

// æŠ˜ç–Šç‹€æ…‹ (é€™å±¬æ–¼ View çš„ç‹€æ…‹ï¼Œç•™åœ¨é€™è£¡å³å¯)
const isOpen = reactive({
  stats: true, total: true, main: true, free: true, freeSum: true
});
const toggle = (key: keyof typeof isOpen) => { isOpen[key] = !isOpen[key]; };

// --- ç‰¹æœ‰é‚è¼¯ï¼šè¨ˆç®—é¡¯ç¤ºæ•¸æ“š ---
// é€™è£¡ä¿ç•™çš„æ˜¯ã€Œåªæœ‰ BaseReport æ‰æœƒç”¨åˆ°çš„ã€ç‰¹å®šè¨ˆç®—é‚è¼¯
const stats = computed(() => {
  const d = props.data;
  const exit = d.exitRateTest || { rate: 0, winPlayers: 0, players: 0 };
  
  return {
    total: {
      rtp: d.rtp,
      win: d.totalWin,
      bet: d.totalBet,
      exitRate: exit.rate,
      survivalRate: safeDiv(exit.winPlayers, exit.players),
      sd: d.SD,
      ci_max: d.CI_MAX, ci_min: d.CI_MIN, maxWin: d.MaxWin
    },
    main: {
      rtp: safeDiv(d.mainWin, d.totalBet),
      win: d.mainWin,
      times: d.spinTimes,
      hitRate: safeDiv(d.mainWinTimes, d.spinTimes)
    },
    free: {
      exists: d.freeTimes > 0,
      rtp: safeDiv(d.freeWin, d.totalBet),
      win: d.freeWin,
      times: d.freeTimes,
      spinTimes: d.freeSpinTimes,
      avgOccur: d.freeTimes > 0 ? safeDiv(d.spinTimes, d.freeTimes) : 0,
      avgMultiple: d.freeTimes > 0 ? safeDiv(d.freeWin / d.freeTimes, d.bet) : 0,
      avgSpinCount: safeDiv(d.freeSpinTimes, d.freeTimes),
      avgSpinWin: d.freeSpinTimes > 0 ? safeDiv(d.freeWin / d.freeSpinTimes, d.bet) : 0,
      hitRate: safeDiv(d.freeWinTimes, d.freeSpinTimes)
    }
  };
});

// è¨ˆç®—åˆ†ä½ˆåˆ—è¡¨ (åŒ…å« RTP æ¬„ä½)
const distLists = computed(() => {
  const process = (list: any[]) => {
    if (!list) return [];
    return list.map(item => ({
      ...item,
      // è¨ˆç®—è©²å€é–“çš„ RTP è²¢ç»
      rtp: props.data.totalBet > 0 ? (item.count * item.avg * props.data.bet) / props.data.totalBet : 0
    }));
  };
  return {
    total: process(props.data.totalSecret),
    main: process(props.data.mainSecret),
    free: process(props.data.freeSecret),
    freeSum: process(props.data.freeSumSecret)
  };
});
</script>

<template>
  <div class="report-container custom-scrollbar">
    
    <div class="section-card">
      <div class="section-header" @click="toggle('stats')">
        <span class="toggle-icon">{{ isOpen.stats ? 'â–¼' : 'â–¶' }}</span>
        <span class="title">çµ±è¨ˆæ¦‚è¦½ (Statistics)</span>
      </div>
      
      <div v-show="isOpen.stats" class="section-body grid-3-col">
        <div class="stat-box">
          <div class="box-title">æ•´é«” (Total)</div>
          <table class="data-table">
            <tbody>
              <tr class="highlight"><td>RTP</td><td>{{ stats.total.rtp }}</td></tr>
              <tr><td>è´åˆ† (Win)</td><td>{{ fmt.money(stats.total.win) }}</td></tr>
              <tr><td>æŠ¼åˆ† (Bet)</td><td>{{ fmt.money(stats.total.bet) }}</td></tr>
              <tr><td>é€€å¹£ç‡ (Return)</td><td>{{ fmt.percent(stats.total.exitRate) }}</td></tr>
              <tr><td>å­˜æ´»ç‡ (Survival)</td><td>{{ fmt.percent(stats.total.survivalRate) }}</td></tr>
              <tr><td>æ¨™æº–å·® (SD)</td><td>{{ fmt.fixed(stats.total.sd, 2) }}</td></tr>
              <tr><td>CI (95%)</td><td>{{ stats.total.ci_min }} ~ {{ stats.total.ci_max }}</td></tr>
              <tr><td>æœ€å¤§å€æ•¸ (MaxWin)</td><td>{{ fmt.fixed(stats.total.maxWin / props.data.bet) }}x</td></tr>
            </tbody>
          </table>
        </div>
        </div>
    </div>

    <div class="section-card">
      <div class="section-header" @click="toggle('total')">
        <span class="toggle-icon">{{ isOpen.total ? 'â–¼' : 'â–¶' }}</span>
        <span class="title">å€æ•¸åˆ†æ - æ•´é«” (Total Distribution)</span>
      </div>
      <div v-show="isOpen.total" class="section-body">
        <table class="full-width-table">
          <thead>
            <tr>
              <th>å€æ•¸å€é–“</th>
              <th>æ¬¡æ•¸</th>
              <th>å¹¾è½‰å‡ºä¸€æ¬¡ (Hit Rate)</th>
              <th>RTP è²¢ç»</th>
            </tr>
          </thead>
          <tbody>
            <tr v-for="(v, i) in distLists.total" :key="i">
              <td>{{ v.label || `${v.min} ~ ${v.max}` }}</td>
              <td>{{ fmt.num(v.count) }}</td>
              <td>{{ v.count > 0 ? fmt.fixed(props.data.spinTimes / v.count, 1) : '-' }}</td>
              <td>{{ fmt.percent(v.rtp, 4) }}</td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>

    </div>
</template>
--- END OF FILE: src\components\reports\BaseReportView.vue ---

--- START OF FILE: src\components\reports\index.ts ---
// src/components/reports/index.ts
import BaseReportView from './BaseReportView.vue';
// import LineReportView from './LineReportView.vue'; // æœªä¾†æ“´å……

// é€™è£¡è¨»å†Šæ‰€æœ‰çš„å ±è¡¨å…ƒä»¶
export const ReportViewRegistry: Record<string, any> = {
  'BaseReportView': BaseReportView,
  // 'LineReportView': LineReportView
};
--- END OF FILE: src\components\reports\index.ts ---

--- START OF FILE: src\components\ReportWindow.vue ---
<template>
  <div class="report-window-container">
    <div v-if="loading" class="loading">Loading Report Data...</div>
    <div v-else-if="error" class="error">{{ error }}</div>
    
    <div v-else class="report-content">
      <div v-for="(comp, index) in reportComponents" :key="index" class="report-wrapper">
        <component 
          v-if="ReportViewRegistry[comp.view]"
          :is="ReportViewRegistry[comp.view]" 
          :data="resultData[getResultKey(comp.model)]" 
        />
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted } from 'vue';
import { ReportViewRegistry } from './reports';
import '../styles/report.css'; // å¼•å…¥æ¨£å¼

const loading = ref(true);
const error = ref('');
const resultData = ref<any>(null);
const reportComponents = ref<any[]>([]);

const getResultKey = (modelName: string) => {
  if (modelName === 'BaseStatModule') return 'base';
  if (modelName === 'LineStatModule') return 'lines';
  return modelName.toLowerCase();
};

onMounted(async () => {
  try {
    // ğŸ”¥ å‘å¾Œç«¯é ˜å–æš«å­˜çš„å ±è¡¨æ•¸æ“š
    const data = await window.ipcRenderer.invoke('report:get-data');
    if (data && data.result) {
      resultData.value = data.result;
      reportComponents.value = data.components || [];
    } else {
      error.value = "No report data found.";
    }
  } catch (e: any) {
    error.value = e.message;
  } finally {
    loading.value = false;
  }
});
</script>

/* src/components/ReportWindow.vue */

<style scoped>
.report-window-container {
  /* ğŸ”¥ é—œéµä¿®æ”¹ 1ï¼šè¨­å®šå›ºå®šé«˜åº¦ç‚ºè¦–çª—é«˜åº¦ */
  height: 100vh; 
  
  /* ğŸ”¥ é—œéµä¿®æ”¹ 2ï¼šå…§å®¹æº¢å‡ºæ™‚ï¼Œè®“é€™å€‹å®¹å™¨è‡ªå·±ç”¢ç”Ÿæ²è»¸ */
  overflow-y: auto; 

  padding: 20px;
  background-color: var(--bg-app);
  color: var(--text-primary);
  box-sizing: border-box; /* ç¢ºä¿ padding ä¸æœƒæ’ç ´å¯¬åº¦ */
}

.report-wrapper { 
  margin-bottom: 20px; 
}

.loading, .error { 
  text-align: center; 
  margin-top: 50px; 
  font-size: 18px; 
}
.error { 
  color: var(--danger); 
}

/* (é¸ç”¨) è®“æ²è»¸æ¼‚äº®ä¸€é»ï¼Œè·Ÿ Dashboard çµ±ä¸€é¢¨æ ¼ */
.report-window-container::-webkit-scrollbar {
  width: 10px;
}
.report-window-container::-webkit-scrollbar-track {
  background: var(--bg-app);
}
.report-window-container::-webkit-scrollbar-thumb {
  background: #555;
  border-radius: 5px;
  border: 2px solid var(--bg-app);
}
.report-window-container::-webkit-scrollbar-thumb:hover {
  background: #777;
}
</style>
--- END OF FILE: src\components\ReportWindow.vue ---

--- START OF FILE: src\components\SlotMachine.vue ---
<script setup lang="ts">
import { useSymbolVisuals } from '../composables/useSymbolVisuals';
import '../styles/slot-machine.css';

interface Props {
  reelData?: string[][]; 
  isSpinning?: boolean;
  winningCells?: Set<string>;
}
const props = withDefaults(defineProps<Props>(), {
  reelData: () => [],
  isSpinning: false,
  winningCells: () => new Set()
});

// å¼•å…¥æ–°çš„åœ–ç‰‡é‚è¼¯
const { getSymbolImage, getSymbolStyle } = useSymbolVisuals();

// åœ–ç‰‡è¼‰å…¥å¤±æ•—ï¼šéš±è—
const handleImgError = (e: Event) => {
  const target = e.target as HTMLImageElement;
  target.style.display = 'none'; // è—èµ·ä¾†
};

// ğŸ”¥ æ–°å¢ï¼šåœ–ç‰‡è¼‰å…¥æˆåŠŸï¼šé¡¯ç¤º (æŠŠ display: none æ‹¿æ‰)
const handleImgLoad = (e: Event) => {
  const target = e.target as HTMLImageElement;
  target.style.display = ''; // æ¸…ç©º display æ¨£å¼ï¼Œå›å¾©é è¨­
};

const isWinner = (col: number, row: number) => {
  return props.winningCells?.has(`${col},${row}`);
};
</script>

<template>
  <div class="slot-machine-container">
    <div class="reel-frame" :class="{ 'spinning': isSpinning }">
      <div v-for="(col, colIndex) in props.reelData" :key="`col-${colIndex}`" class="reel-col">
        <div 
          v-for="(symbolId, rowIndex) in col" 
          :key="`sym-${colIndex}-${rowIndex}`" 
          class="symbol-cell"
          :class="{ 'win-anim': isWinner(colIndex, rowIndex) }"
        > 
        <div class="symbol-inner" :style="getSymbolStyle(symbolId)">
            <img 
              :src="getSymbolImage(symbolId)" 
              :alt="symbolId"
              class="symbol-img"
              @error="handleImgError"
              @load="handleImgLoad"
            />
            <span class="id-overlay">{{ symbolId }}</span>
          </div>

          <span class="coord-debug">{{ colIndex }},{{ rowIndex }}</span>
        </div>
      </div>
    </div>
  </div>
</template>
--- END OF FILE: src\components\SlotMachine.vue ---

--- START OF FILE: src\composables\useReportUtils.ts ---
/**
 * å ±è¡¨å…±ç”¨å·¥å…·å‡½å¼
 */
export function useReportUtils() {

  // å®‰å…¨é™¤æ³•ï¼šé˜²æ­¢åˆ†æ¯ç‚º 0 å‡ºç¾ Infinity æˆ– NaN
  const safeDiv = (a: number, b: number) => (b > 0 ? a / b : 0);

  // æ ¼å¼åŒ–å·¥å…·
  const fmt = {
    // é‡‘é¡ (æ•´æ•¸åŠ é€—è™Ÿ)
    money: (val: number) => Math.floor(val).toLocaleString(),

    // æ•¸å­— (ä¿ç•™åŸå§‹å°æ•¸æˆ–æ•´æ•¸ï¼ŒåŠ é€—è™Ÿ)
    num: (val: number) => val.toLocaleString(),

    // å›ºå®šå°æ•¸ä½æ•¸
    fixed: (val: number, d = 2) => Number(val || 0).toFixed(d),

    // ç™¾åˆ†æ¯”
    percent: (val: number, d = 2) => (Number(val || 0) * 100).toFixed(d) + '%'
  };

  return {
    safeDiv,
    fmt
  };
}
--- END OF FILE: src\composables\useReportUtils.ts ---

--- START OF FILE: src\composables\useSlotGame.ts ---
// src/composables/useSlotGame.ts

import { ref, reactive, onMounted, computed } from 'vue';

export interface LogDetail { text: string; type: 'sub' | 'detail'; }
export interface LogEntry { id: number; title: string; details: LogDetail[]; isExpanded: boolean; }

export function useSlotGame() {

  const isSpinning = ref(false);
  const winningCells = ref<Set<string>>(new Set());
  const logs = ref<LogEntry[]>([]);
  let logIdCounter = 0;

  const exportOptions = reactive({
    useZip: false,      // æ˜¯å¦å£“ç¸® config
    exportSource: false // æ˜¯å¦åŒ¯å‡º Excel source
  });

  const stats = reactive({
    totalSpin: 0,
    totalBet: 0,
    totalWin: 0,
    rtp: '0.0%',
    totalCashIn: 10000
  });

  const config = reactive({
    rtpSetting: 0.965,
    maxWin: undefined,
    volatility: 40,
    takeProfit: 100,
    stopLoss: 500,
    rounds: 1000000,
    selectedMode: 'default' as string | number,
    modeType: 'default' as string | number
  });

  const defaultOptions = [
    { label: 'Default', value: 'default', type: 'default' },
    { label: 'Y0 (4000-6000)', value: 0, type: 'yPrize' },
    { label: 'Y1 (2000-4000)', value: 1, type: 'yPrize' },
    { label: 'Y2 (1000-2000)', value: 2, type: 'yPrize' },
    { label: 'Y3 (500-1000)', value: 3, type: 'yPrize' }
  ];

  const modeOptions = ref([...defaultOptions]);

  const roundOptions = [1000, 10000, 100000, 1000_000, 3000_000, 5000_000, 10_000_000, 30_000_000, 50_000_000];
  let line_count = 25;

  const showDetails = ref(true);
  const excelFiles = ref<string[]>([]);
  const selectedExcelFile = ref('');

  // ğŸ”¥ ä¸»é¡Œç‹€æ…‹
  const isDarkMode = ref(true);

  const betLevels = ref<number[]>([]);
  const currentBetIndex = ref(0);
  const currentBetAmount = computed(() => {
    if (betLevels.value.length === 0) return 0;
    return betLevels.value[currentBetIndex.value];
  });

  const formatAmount = (num: number) => {
    return Math.round(num * 10000) / 10000;
  };

  // ğŸ”¥ ä¸»é¡Œåˆ‡æ›é‚è¼¯
  const toggleTheme = () => {
    isDarkMode.value = !isDarkMode.value;
    updateTheme();
  };

  const updateTheme = () => {
    const theme = isDarkMode.value ? 'dark' : 'light';
    document.documentElement.setAttribute('data-theme', theme);
    localStorage.setItem('theme', theme);
  };

  // --- æ­·å²ç›¤é¢ç³»çµ± ---
  interface GameFrame { label: string; grid: string[][]; win: number; winningLines: number[][]; }
  const spinHistory = ref<GameFrame[]>([]);
  const currentFrameIndex = ref(0);
  const currentGrid = computed(() => spinHistory.value.length === 0 ? [['0', '0', '0'], ['0', '0', '0'], ['0', '0', '0'], ['0', '0', '0'], ['0', '0', '0']] : spinHistory.value[currentFrameIndex.value].grid);
  const currentWin = computed(() => spinHistory.value.length === 0 ? 0 : spinHistory.value[currentFrameIndex.value].win);
  const dynamicPaylines = ref<number[][]>([]);
  const symbolMap = reactive<Record<number, string>>({});

  const initGame = async () => {
    try {
      // ğŸ”¥ åˆå§‹åŒ–ä¸»é¡Œ
      const savedTheme = localStorage.getItem('theme');
      if (savedTheme === 'light') {
        isDarkMode.value = false;
      } else {
        isDarkMode.value = true;
      }
      updateTheme();

      const gameConfig = await window.ipcRenderer.invoke('game:init');
      const files = await window.ipcRenderer.invoke('system:get-excel-files');
      excelFiles.value = files;
      if (files.length > 0) selectedExcelFile.value = files[0];

      if (gameConfig.paylines) {
        dynamicPaylines.value = gameConfig.paylines;
        logs.value.unshift({ id: logIdCounter++, title: `[ç³»çµ±] å·²è¼‰å…¥æ©Ÿç‡æ¨¡å‹`, details: [], isExpanded: false });
      }
      if (gameConfig.paytable) {
        for (const key in symbolMap) delete symbolMap[Number(key)];
        Object.values(gameConfig.paytable).forEach((symbol: any) => {
          if (symbol.id !== undefined && symbol.name !== undefined) symbolMap[symbol.id] = symbol.name;
        });
      }
      if (gameConfig.buyFeatureInfos) {
        modeOptions.value = [...defaultOptions];
        const features = gameConfig.buyFeatureInfos;
        // éæ­·ç‰©ä»¶ï¼Œæ ¼å¼é€šå¸¸æ˜¯ key: { name, type, rate... }
        Object.keys(features).forEach(key => {
          const item = features[key];
          // åŠ å…¥é¸é …ï¼Œé¡¯ç¤ºåç¨±å’Œåƒ¹æ ¼å€æ•¸
          modeOptions.value.push({
            label: `${item.name}`, // ä¾‹å¦‚: Free Game (x100)
            value: item.type, // ä½¿ç”¨ type ä½œç‚º value
            type: 'buyFeature'
          });
        });
      }
      if (gameConfig.lineCount) {
        const lines = gameConfig.lineCount;
        line_count = lines;
        const levels = [];
        for (let i = 1; i <= 10; i++) levels.push(lines * i);
        betLevels.value = levels;
        currentBetIndex.value = 0;
      }
    } catch (e: any) {
      console.error('Init Game Error:', e);
    }
  };

  const switchFrame = (index: number) => {

    if (index < 0 || index >= spinHistory.value.length) return;
    currentFrameIndex.value = index;
    const frame = spinHistory.value[index];
    winningCells.value.clear();
    frame.winningLines.forEach((lineData) => {
      const lineId = lineData[0];
      const count = lineData[2];
      const geometry = dynamicPaylines.value[lineId];
      if (geometry) {
        for (let col = 0; col < count; col++) {
          const row = geometry[col];
          winningCells.value.add(`${col},${row}`);
        }
      }
    });
  };

  const generatePrizeLogs = (prizes: any, logType: 'sub' | 'detail', bet: number): LogDetail[] => {

    const details: LogDetail[] = [];
    if (!prizes) return details;
    if (prizes.line && prizes.line.prizes) {
      prizes.line.prizes.forEach((p: any[]) => {
        const symName = symbolMap[p[1]] || `ID-${p[1]}`;
        const lineWin = formatAmount((p[3] / line_count) * bet);
        details.push({ text: `...... Line ${p[0] + 1}ã€${symName}ã€${p[2]}é€£ç·š è´:${lineWin}`, type: logType });
      });
    }
    if (prizes.scatter && prizes.scatter.prizes) {
      prizes.scatter.prizes.forEach((p: any[]) => {
        const symName = symbolMap[p[0]] || `ID-${p[0]}`;
        const scWin = formatAmount((p[2] / line_count) * bet);
        details.push({ text: `...... Scatterã€${symName}ã€x${p[1]} è´:${scWin}`, type: logType });
      });
    }
    if (prizes.ways && prizes.ways.prizes) {
      prizes.ways.prizes.forEach((p: any[]) => {
        const symName = symbolMap[p[0]] || `ID-${p[0]}`;
        const wayWin = formatAmount((p[2] / line_count) * bet);
        details.push({ text: `...... Wayã€${symName}ã€x${p[1]} è´:${wayWin}`, type: logType });
      });
    }
    return details;
  };

  const createSpinInfo = (bet: number) => {

    let targetPrizeType = undefined;
    let buyFeatureType = undefined;
    let randMode = 'default'; // é è¨­è®€å– default.json

    const currentModeOption = modeOptions.value.find(
      opt => opt.value === config.selectedMode && opt.type === config.modeType
    );
    if (currentModeOption) {
      if (currentModeOption.type === 'buyFeature') {
        buyFeatureType = currentModeOption.value;
      } else if (currentModeOption.type === 'yPrize') {
        targetPrizeType = currentModeOption.value;
      } else {
        buyFeatureType = undefined;
        targetPrizeType = undefined;
      }
    }
    const spinInfo = {
      betLv: betLevels.value.indexOf(bet),
      lineBet: bet / line_count,
      buyFeatureType: buyFeatureType,
      targetRTP: config.rtpSetting,
      targetPrizeType: targetPrizeType,
      targetWinLimit: config.maxWin,
      randMode: randMode
    }
    return spinInfo;
  }

  const handleSpin = async () => {

    if (isSpinning.value) return;
    isSpinning.value = true;
    spinHistory.value = [{
      label: 'ä¸»éŠæˆ²',
      // é€™è£¡å¯ä»¥çµ¦å…¨ 0ï¼Œæˆ–è€…ä¿ç•™ä¸Šä¸€å±€çš„ç•«é¢(currentGrid.value)
      grid: [['0', '0', '0'], ['0', '0', '0'], ['0', '0', '0'], ['0', '0', '0'], ['0', '0', '0']],
      win: 0,
      winningLines: []
    }];
    currentFrameIndex.value = 0;
    winningCells.value.clear();
    const bet = currentBetAmount.value;

    try {

      const spinInfo = createSpinInfo(bet);

      const result = await window.ipcRenderer.invoke('game:spin', spinInfo);

      if (result && result.game) {

        spinHistory.value = [];
        const rawTotalWin = (result.game.totalWin[0] / line_count + result.game.totalWin[1]) * bet;
        const totalRoundWin = formatAmount(rawTotalWin);
        const newLog: LogEntry = { id: logIdCounter++, title: `(${stats.totalSpin + 1}) æŠ¼åˆ†:${bet}, è´åˆ†: $${totalRoundWin}`, details: [], isExpanded: true };

        const processGameFrame = (label: string, rawReels: number[][], rawWin: number, prizes: any, logType: 'sub' | 'detail', bet: number) => {

          const grid = rawReels.map((col) => col.map(String));
          const visualLines = prizes?.line?.prizes || [];
          const frameWin = formatAmount(rawWin);
          spinHistory.value.push({ label, grid, win: frameWin, winningLines: visualLines });
          newLog.details.push({ text: `[${label}] è´åˆ†: $${frameWin}`, type: 'sub' });
          const detailLogs = generatePrizeLogs(prizes, logType, bet);
          newLog.details.push(...detailLogs);
        };

        if (result.game.plate && result.game.plate.reels) {
          const mainWin = (result.game.mainWin[0] / line_count + result.game.mainWin[1]) * bet;
          processGameFrame('ä¸»éŠæˆ²', result.game.plate.reels, mainWin, result.game.prizes, 'detail', bet);
        }

        if (result.game.free && result.game.free.results) {
          result.game.free.results.forEach((freeRes: any, idx: number) => {
            const freeWin = (freeRes.prizes?.win[0] / line_count + freeRes.prizes?.win[1]) * bet;
            processGameFrame(`FG-${idx + 1}`, freeRes.plate.reels, freeWin, freeRes.prizes, 'detail', bet);
          });
        }

        logs.value.unshift(newLog);
        if (logs.value.length > 50) logs.value.pop();
        stats.totalWin = formatAmount(stats.totalWin + totalRoundWin);
        stats.totalBet += bet;
        stats.totalSpin += 1;
        if (stats.totalBet > 0) stats.rtp = ((stats.totalWin / stats.totalBet) * 100).toFixed(2) + '%';
        switchFrame(0);
      }
    } catch (error: any) {
      console.error('Spin Error:', error);
      logs.value.unshift({ id: logIdCounter++, title: `[éŒ¯èª¤] ${error.message}`, details: [], isExpanded: false });
    } finally {
      isSpinning.value = false;
    }
  };

  const handleModeChange = (modeValue: string | number, modeType: string | number) => {
    // 1. è¨­å®šé¸å–çš„æ¨¡å¼
    config.selectedMode = modeValue;
    config.modeType = modeType;

    // 2. æ‰¾å‡ºå°æ‡‰çš„æ¨™ç±¤åç¨± (ç‚ºäº†è®“ Log é¡¯ç¤º User çœ‹å¾—æ‡‚çš„æ–‡å­—)
    const targetMode = modeOptions.value.find(m => m.value === modeValue && m.type === modeType);
    const modeLabel = targetMode ? targetMode.label : modeValue;

    // 3. å¯«å…¥ Log
    logs.value.unshift({
      id: Date.now(),
      title: `[ç³»çµ±] åˆ‡æ›æ¨¡å¼: ${modeLabel}`,
      details: [], // ä¸éœ€è¦è©³ç´°å…§å®¹ï¼Œæ¨™é¡Œå°±å¤ äº†
      isExpanded: false
    });
  };

  const handleReload = async () => {
    if (isSpinning.value) return; // è½‰å‹•ä¸­ä¸çµ¦é‡è¼‰

    // 1. è¨­å®š loading ç‹€æ…‹ (å¯é¸)
    isSpinning.value = true;

    try {
      // 2. å‘¼å«å¾Œç«¯
      logs.value.unshift({ id: Date.now(), title: `[ç³»çµ±] æ­£åœ¨é‡æ–°è¼‰å…¥è¨­å®š (Reloading)...`, details: [], isExpanded: false });

      const res = await window.ipcRenderer.invoke('system:reload');

      if (res.success) {

        // æ¸…ç©º Log
        logs.value = [];
        logs.value.push({ id: Date.now(), title: `[ç³»çµ±] é‡è¼‰å®Œæˆï¼Œç‹€æ…‹å·²é‡ç½®`, details: [], isExpanded: false });

        // é‡ç½®çµ±è¨ˆ
        stats.totalSpin = 0;
        stats.totalBet = 0;
        stats.totalWin = 0;
        stats.rtp = '0.0%';
        stats.totalCashIn = 10000; // è¦–éœ€æ±‚æ˜¯å¦é‡ç½®é¤˜é¡

        spinHistory.value = [];
        currentFrameIndex.value = 0;
        winningCells.value.clear();

        await initGame();

      } else {
        logs.value.unshift({ id: Date.now(), title: `[éŒ¯èª¤] é‡è¼‰å¤±æ•—: ${res.error}`, details: [], isExpanded: false });
      }

    } catch (e: any) {
      console.error('Reload Error:', e);
    } finally {
      isSpinning.value = false;
    }
  };

  const onLightningClick = async () => { // æ”¹åæˆ–æ•´åˆé€² handleLightning
    if (isSpinning.value) return;

    const payload = getLightningConfig();

    // ğŸ”¥ å‰ç«¯åªè² è²¬é€å‡ºã€Œé–‹å§‹ã€æŒ‡ä»¤ï¼Œå‰©ä¸‹çš„è¦–çª—ç®¡ç†äº¤çµ¦å¾Œç«¯
    // ä¸éœ€è¦ await çµæœï¼Œå› ç‚ºå¾Œç«¯æœƒè‡ªå·±é–‹è¦–çª—
    // ä½†ç‚ºäº†é¿å…é‡è¤‡é»æ“Šï¼Œå¯ä»¥åŠ å€‹ç°¡å–®çš„ flag
    window.ipcRenderer.invoke('game:lightning', payload);
  };

  const getLightningConfig = () => {
    if (isSpinning.value) return;

    const spinInfo = createSpinInfo(currentBetAmount.value);

    const rawPayload = {
      simConfig:{
        rounds: config.rounds,
        targetRTP: spinInfo.targetRTP,
        betlv: spinInfo.betLv,
        lineBet: spinInfo.lineBet,
        buyFeatureType: spinInfo.buyFeatureType,
        targetPrizeType: spinInfo.targetPrizeType,
        targetWinLimit: spinInfo.targetWinLimit,
        randMode: spinInfo.randMode,
        bets: betLevels.value,
        lineCount: line_count,
      },
      exitInfo:{
        exitStart: Number(config.volatility),
        exitEnd: Number(config.takeProfit),
        exitMaxWin: Number(config.stopLoss)
      }
    }

    return JSON.parse(JSON.stringify(rawPayload)); // æ·±æ‹·è²ï¼Œç¢ºä¿æ²’æœ‰ reactive ç‰©ä»¶è¢«å‚³åˆ°å¾Œç«¯
  };

  const openFile = async (fileName: string) => {
    try {
      logs.value.unshift({ id: Date.now(), title: `[ç³»çµ±] é–‹å•Ÿ ${fileName}...`, details: [], isExpanded: false });
      const res = await window.ipcRenderer.invoke('system:open-file', fileName);
      if (!res.success) {
        logs.value.unshift({ id: Date.now() + 1, title: `[éŒ¯èª¤] ç„¡æ³•é–‹å•Ÿæª”æ¡ˆ: ${res.error}`, details: [], isExpanded: false });
      } else {
        logs.value.unshift({ id: Date.now() + 1, title: `[ç³»çµ±] æª”æ¡ˆå·²é–‹å•Ÿ: ${fileName}`, details: [], isExpanded: false });
      }
    } catch (e: any) {
      console.error('Open File Error:', e);
    }
  };

  const handleExport = async () => {
    // é˜²æ­¢é‡è¤‡é»æ“Šæˆ–è½‰å‹•æ™‚åŒ¯å‡º
    if (isSpinning.value) return;

    try {
      logs.value.unshift({
        id: Date.now(),
        title: `[ç³»çµ±] æº–å‚™åŒ¯å‡ºéŠæˆ²æ ¸å¿ƒ (Exporting)...`,
        details: [],
        isExpanded: false
      });

      // å‘¼å«å¾Œç«¯
      const res = await window.ipcRenderer.invoke('system:export', JSON.parse(JSON.stringify(exportOptions)));

      if (res.success) {
        logs.value.unshift({
          id: Date.now() + 1,
          title: `[ç³»çµ±] åŒ¯å‡ºæˆåŠŸï¼`,
          details: [{ text: `å·²å„²å­˜è‡³: ${res.path}`, type: 'sub' }],
          isExpanded: true
        });
      } else if (res.cancelled) {
        logs.value.unshift({
          id: Date.now() + 1,
          title: `[ç³»çµ±] å–æ¶ˆåŒ¯å‡º`,
          details: [],
          isExpanded: false
        });
      } else {
        logs.value.unshift({
          id: Date.now() + 1,
          title: `[éŒ¯èª¤] åŒ¯å‡ºå¤±æ•—: ${res.error}`,
          details: [],
          isExpanded: true
        });
      }
    } catch (e: any) {
      console.error('Export Error:', e);
    }
  };

  onMounted(() => { initGame(); });

  return {
    logs, stats, config, currentGrid, isSpinning, handleSpin, winningCells, currentWin, betLevels, currentBetIndex, currentBetAmount, spinHistory, currentFrameIndex, switchFrame, showDetails, openFile, excelFiles, selectedExcelFile, roundOptions, formatAmount, modeOptions,
    isDarkMode, toggleTheme, handleReload, handleExport, handleModeChange, getLightningConfig, exportOptions, onLightningClick
  };
}
--- END OF FILE: src\composables\useSlotGame.ts ---

--- START OF FILE: src\composables\useSymbolVisuals.ts ---
// src/composables/useSymbolVisuals.ts

export function useSymbolVisuals() {

  // 1. ç”¢ç”Ÿåœ–ç‰‡è·¯å¾‘
  // Vite çš„ public è³‡æ–™å¤¾å°æ‡‰åˆ°ç¶²é æ ¹ç›®éŒ„ "/"
  const getSymbolImage = (symbolId: string) => {
    // å‡è¨­ä½ çš„åœ–ç‰‡æ ¼å¼éƒ½æ˜¯ png
    if (symbolId === '23') symbolId = '22'
    return `/symbols/${symbolId}.png`;
  };

  const getSymbolStyle = (symbolId: string) => {
    // åˆ¤æ–·æ˜¯å¦ç‚ºé»ƒé‡‘ Wild (23)
    const isGolden = symbolId === '23';

    return {
      // å¦‚æœä¸æ˜¯ 23ï¼Œå°±ç”¨åŸæœ¬çš„ #222 (æ·±è‰²èƒŒæ™¯) 23æ˜¯é»ƒé‡‘WILD
      background: isGolden
        ? 'linear-gradient(135deg, #fff8db 0%, #ffd700 40%, #d4af37 100%)'
        : '#222',

      // é‚Šæ¡†ï¼šé‡‘è‰²èƒŒæ™¯é…ç™½è‰²æˆ–äº®é»ƒè‰²é‚Šæ¡†æ¯”è¼ƒé¡¯çœ¼
      border: isGolden ? '2px solid #fff' : '1px solid #333',

      // é™°å½±ï¼šåŠ å¼·é‡‘è‰²å…‰æšˆ
      boxShadow: isGolden ? '0 0 15px rgba(255, 215, 0, 0.6)' : 'none',

      // ç¢ºä¿åœ“è§’ (é…åˆ CSS)
      borderRadius: '6px'
    };
  };

  return { getSymbolImage, getSymbolStyle };
}
--- END OF FILE: src\composables\useSymbolVisuals.ts ---

--- START OF FILE: src\main.ts ---
import { createApp } from 'vue'
import './style.css'
import App from './App.vue'

createApp(App).mount('#app').$nextTick(() => {
  // Use contextBridge
  window.ipcRenderer.on('main-process-message', (_event, message) => {
    console.log(message)
  })
})

--- END OF FILE: src\main.ts ---

--- START OF FILE: src\style.css ---
/* src/style.css */

/* é‡ç½®ç€è¦½å™¨é è¨­é‚Šè· */
body {
  margin: 0;
  padding: 0;
  overflow: hidden; /* é˜²æ­¢è¦–çª—å‡ºç¾ä¸å¿…è¦çš„æ²è»¸ */
  background-color: #1e1e1e; /* é…åˆä½ çš„æ·±è‰²ä¸»é¡Œ */
}

/* ç¢ºä¿ #app æ’æ»¿å…¨è¢å¹• */
#app {
  width: 100vw;
  height: 100vh;
}
--- END OF FILE: src\style.css ---

--- START OF FILE: src\styles\dashboard.css ---
/* src/styles/dashboard.css */

/* --- 1. å®šç¾©é¡è‰²è®Šæ•¸ (æ ¸å¿ƒç³»çµ±) --- */
:root {
  /* --- æ·±è‰²ä¸»é¡Œ (é è¨­) --- */
  /* æ ¸å¿ƒèƒŒæ™¯ */
  --bg-app: #1e1e1e;
  --bg-panel: #252526;
  --bg-panel-header: #333333;

  /* å…ƒä»¶èƒŒæ™¯ */
  --bg-input: #1e1e1e; /* è¼¸å…¥æ¡†æ·±å‡¹æ„Ÿ */
  --bg-hover: #2a2d2e;
  --bg-card-header: rgba(255, 255, 255, 0.03); /* å¡ç‰‡æ¨™é¡Œå¾®äº® */

  /* é‚Šæ¡†èˆ‡æ–‡å­— */
  --border-color: #454545;
  --text-primary: #cccccc;
  --text-secondary: #969696;

  /* é‡é»è‰² */
  --accent-blue: #0e639c;
  --accent-blue-hover: #1177bb;
  --accent-green: #22863a;
  --danger: #d73a49;
}

[data-theme="light"] {
  /* æ ¸å¿ƒèƒŒæ™¯ï¼šæ”¹ç”¨æŸ”å’Œçš„ç°ï¼Œä¸å†æ˜¯åˆºçœ¼ç´”ç™½ */
  --bg-app: #e3e5e8; /* APP åº•è‰²ï¼šå†·ç° */
  --bg-panel: #f7f9fc; /* é¢æ¿ï¼šæ¥µæ·ºçš„ç°ç™½ */
  --bg-panel-header: #ebeef2; /* æ¨™é¡Œåˆ—ï¼šç¨æ·±çš„ç° */

  /* å…ƒä»¶èƒŒæ™¯ */
  --bg-input: #ffffff; /* è¼¸å…¥æ¡†ç¶­æŒç´”ç™½ï¼Œç¢ºä¿å¯è®€æ€§ */
  --bg-hover: #dbe0e6; /* æ»‘é¼ æ‡¸åœ */
  --bg-card-header: #e1e4e8;

  /* é‚Šæ¡†èˆ‡æ–‡å­— */
  --border-color: #cacedb; /* é‚Šæ¡†åŠ æ·±ï¼Œå¢åŠ ç«‹é«”æ„Ÿ */
  --text-primary: #2c3e50; /* æ·±è—ç°æ–‡å­—ï¼Œæ¯”ç´”é»‘æŸ”å’Œ */
  --text-secondary: #5f6c7b;

  /* é‡é»è‰² (ç¨å¾®èª¿æ•´ä»¥é…åˆç°è‰²) */
  --accent-blue: #0065b3;
  --accent-blue-hover: #005699;
  --accent-green: #15803d;
  --danger: #dc2626;
}

/* --- åŸºç¤è¨­å®š --- */
* {
  box-sizing: border-box;
}
body {
  margin: 0;
  padding: 0;
  font-family: "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
  -webkit-font-smoothing: antialiased;
  font-size: 12px;
  color: var(--text-primary); /* å…¨åŸŸæ–‡å­—é¡è‰² */
  background-color: var(--bg-app); /* å…¨åŸŸèƒŒæ™¯ */
}

/* --- æ ¸å¿ƒä½ˆå±€ Grid --- */
.dashboard-container {
  display: grid;
  grid-template-columns: 280px 1fr 280px;
  height: 100vh;
  background-color: var(--bg-app);
  overflow: hidden;
}

/* --- é¢æ¿é€šç”¨ --- */
.panel {
  display: flex;
  flex-direction: column;
  background: var(--bg-panel);
  border-right: 1px solid var(--border-color);
  overflow: hidden;
}

.panel-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0 12px;
  background: var(--bg-panel-header);
  border-bottom: 1px solid var(--border-color);
  height: 38px;
  flex-shrink: 0;
}
.panel-title {
  margin: 0;
  font-size: 13px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  color: var(--text-primary);
}

/* --- å·¦å´ Log --- */
.header-tools {
  display: flex;
  align-items: center;
  gap: 10px;
  font-size: 12px;
}
.checkbox-label {
  display: flex;
  align-items: center;
  cursor: pointer;
  user-select: none;
  color: var(--text-secondary);
}
.checkbox-label input {
  margin-right: 6px;
}

.log-content {
  flex: 1;
  background: var(--bg-app);
  padding: 8px;
  overflow-y: auto;
  min-height: 0;
  font-family: "Consolas", "Courier New", monospace;
  font-size: 12px;
}

.log-group {
  border-bottom: 1px solid var(--border-color);
  margin-bottom: 4px;
  padding-bottom: 4px;
}
.log-title {
  cursor: pointer;
  padding: 3px 6px;
  color: var(--text-primary);
  font-weight: bold;
  display: flex;
  align-items: center;
  border-radius: 3px;
  transition: background-color 0.1s;
}
.log-title:hover {
  background-color: var(--bg-hover);
}
.toggle-icon {
  display: inline-block;
  width: 14px;
  font-size: 10px;
  color: var(--text-secondary);
  margin-right: 4px;
}
.log-details {
  padding-left: 20px;
}
.log-detail-item {
  color: var(--text-secondary);
  line-height: 1.5;
  white-space: pre-wrap;
}

/* Log é¡è‰²ç‰¹æ®Šè™•ç† */
[data-theme="light"] .log-detail-item.detail {
  color: #d68a00;
}
[data-theme="dark"] .log-detail-item.detail {
  color: #dcdcaa;
}
[data-theme="light"] .log-detail-item.sub {
  color: #005a9e;
}
[data-theme="dark"] .log-detail-item.sub {
  color: #9cdcfe;
}

/* --- ä¸­é–“ä¸»æ§å° --- */
.center-panel {
  background: var(--bg-app);
  display: grid;
  grid-template-rows: auto auto 1fr auto;
}

.stats-container {
  background: var(--bg-panel);
  padding: 10px;
  border-bottom: 1px solid var(--border-color);
  /* ğŸ”¥ æ–°å¢ï¼šä½¿ç”¨ Flex è®“å…§éƒ¨çš„è¡¨æ ¼æ°´å¹³ç½®ä¸­ */
  display: flex;
  justify-content: center;
}

.stats-table {
  width: 100%;
  /* ğŸ”¥ æ–°å¢ï¼šé™åˆ¶æœ€å¤§å¯¬åº¦ï¼Œè®“æ•¸æ“šé›†ä¸­ */
  max-width: 400px;
  border-collapse: collapse;
  font-size: 13px;
}

.stats-table td {
  padding: 6px 15px;
  border-bottom: 1px solid var(--border-color);
  color: var(--text-primary);
  /* ğŸ”¥ æ–°å¢ï¼šå‚ç›´ç½®ä¸­ */
  vertical-align: middle;
}

.stats-table tr:last-child td {
  border-bottom: none;
}
.stats-table td:nth-child(1) {
  color: var(--text-secondary);
  width: 45%;
}
.stats-table td:nth-child(2) {
  font-weight: bold;
  text-align: right;
}

.balance-bar {
  background: var(--bg-panel-header);
  padding: 8px 15px;
  display: flex;
  align-items: baseline;
  border-bottom: 1px solid var(--border-color);
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
  z-index: 1;
}
.balance-label {
  color: var(--text-secondary);
  margin-right: 10px;
  font-size: 13px;
}
.balance-value {
  font-size: 20px;
  font-weight: bold;
  color: var(--text-primary);
  margin-right: auto;
}
.win-tag {
  color: var(--accent-green);
  font-weight: bold;
  font-size: 15px;
}

/* ğŸ”¥ğŸ”¥ğŸ”¥ éŠæˆ²å€åŸŸå„ªåŒ– ğŸ”¥ğŸ”¥ğŸ”¥ */
.game-area-wrapper {
  display: flex;
  justify-content: center;
  align-items: center;

  /* é è¨­ (æ·±è‰²æ¨¡å¼) */
  background: #000000;
  border: 1px solid #333; /* åŠ å€‹é‚Šæ¡†è®“å®ƒæœ‰é‚Šç•Œæ„Ÿ */

  padding: 20px;
  overflow: hidden;
  box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.5);
  flex-direction: column;
  gap: 12px;

  /* åœ“è§’è®“å®ƒçœ‹èµ·ä¾†æ›´åƒä¸€å€‹è¦–çª— */
  border-radius: 4px;
  margin: 10px; /* ç¨å¾®ç•™ç™½ï¼Œä¸è¦è²¼æ­»é‚Šç·£ */
}

/* ğŸ”¥ é‡å°äº®è‰²æ¨¡å¼çš„ç‰¹æ®Šè¦†å¯«ï¼šéŠ€ç™½é…è‰² */
[data-theme="light"] .game-area-wrapper {
  /* æ”¹ç‚ºç°ç™½è‰²æ¼¸å±¤ï¼Œæ¨¡æ“¬é‡‘å±¬æ©Ÿå°è³ªæ„Ÿ */
  background: linear-gradient(145deg, #f0f0f0 0%, #dcdcdc 100%);

  /* é‚Šæ¡†æ”¹ç‚ºéŠ€ç°è‰² */
  border: 1px solid #b0b0b0;

  /* èª¿æ•´é™°å½±ï¼Œè®“å®ƒæœ‰æµ®èµ·ä¾†çš„ç«‹é«”æ„Ÿ */
  box-shadow:
    5px 5px 15px rgba(0, 0, 0, 0.1),
    -5px -5px 15px rgba(255, 255, 255, 0.8);
}

/* æ­·å²ç›¤é¢å°èˆªåˆ— */
.frame-navigation {
  display: flex;
  gap: 5px;
  padding: 5px;
  /* ğŸ”¥ å¼·åˆ¶ä½¿ç”¨æ·±ç°è‰²èƒŒæ™¯ï¼Œä¸éš¨ Light Mode è®Šç™½ */
  background: #252526;
  border-radius: 4px;
  border: 1px solid #454545;
  max-width: 100%;
  overflow-x: auto;
  min-height: 42px;
}

.frame-btn {
  /* ğŸ”¥ å¼·åˆ¶ä½¿ç”¨æ·±è‰²æŒ‰éˆ•æ¨£å¼ */
  background: #3c3c3c;
  color: #999;
  border: 1px solid #555;
  padding: 4px 10px;
  cursor: pointer;
  font-size: 12px;
  min-width: 55px;
  transition: all 0.1s;
  font-family: "Segoe UI", sans-serif;
  white-space: nowrap;
}

.frame-btn:hover {
  /* ğŸ”¥ Hover ç‹€æ…‹ä¹Ÿå›ºå®šç‚ºæ·±è‰²ç³» */
  background: #4a4a4a;
  color: #fff;
}

.frame-btn.active {
  /* é¸ä¸­ç‹€æ…‹ç¶­æŒè—è‰² */
  background: #0e639c;
  color: white;
  border-color: #0e639c;
  font-weight: bold;
}

.bottom-controls {
  display: flex;
  align-items: stretch;
  background: var(--bg-panel-header);
  height: 65px;
  border-top: 1px solid var(--border-color);
  padding-right: 10px; /* ğŸ”¥ å³å´ç•™ä¸€é»ç©ºé–“ */
}
.bet-control-group {
  display: flex;
  align-items: center;
  padding: 0 10px;
  gap: 10px;
  border-right: 1px solid var(--border-color);
}
.bet-display,
.win-display {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  min-width: 80px;
}
.win-display {
  flex: 1;
  border-right: 1px solid var(--border-color);
  background: rgba(0, 0, 0, 0.05);
}
.bet-display .label,
.win-display .label {
  font-size: 10px;
  color: var(--text-secondary);
  text-transform: uppercase;
}
.bet-display .value,
.win-display .value {
  font-size: 20px;
  font-weight: bold;
  color: var(--text-primary);
}
.win-display .value {
  color: var(--accent-green);
}

/* SPIN æŒ‰éˆ• - é€šç”¨è¨­å®š */
.btn-spin {
  width: 120px;
  height: 48px; /* ğŸ”¥ å›ºå®šé«˜åº¦ï¼Œä¸å¡«æ»¿ */
  align-self: center; /* ğŸ”¥ å‚ç›´ç½®ä¸­ */
  margin: 0 12px; /* ğŸ”¥ å·¦å³ç•™ç™½ï¼Œä¸è²¼é‚Š */
  border-radius: 12px; /* ğŸ”¥ åœ“æ½¤é‚Šè§’ */
  font-size: 18px;
  font-weight: bold;
  color: white;
  background: var(--accent-blue);
  border: none;
  cursor: pointer;
  transition: all 0.2s;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2); /* ğŸ”¥ åŠ ä¸€é»é™°å½± */
}

/* æ·±è‰²æ¨¡å¼ Hover */
.btn-spin:hover:not(:disabled) {
  background: var(--accent-blue-hover);
  transform: translateY(-1px);
  box-shadow: 0 6px 8px rgba(0, 0, 0, 0.3);
}
.btn-spin:disabled {
  background: #555;
  cursor: not-allowed;
  box-shadow: none;
  transform: none;
}

/* ğŸ”¥ é‡å°äº®è‰²æ¨¡å¼çš„ SPIN æŒ‰éˆ•å„ªåŒ–ï¼šæ›´æœ‰è³ªæ„Ÿ */
[data-theme="light"] .btn-spin {
  /* æ¼¸å±¤èƒŒæ™¯ */
  background: linear-gradient(180deg, #3498db 0%, #0e639c 100%);
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);

  /* å¤šå±¤é™°å½±è£½é€ ç«‹é«”æ„Ÿ */
  box-shadow:
    0 0 0 2px #dcdcdc,
    /* éŠ€è‰²å¤–ç’° */ 0 4px 8px rgba(0, 0, 0, 0.3),
    /* å¤–éƒ¨é™°å½± */ inset 0 2px 3px rgba(255, 255, 255, 0.4); /* å…§éƒ¨é«˜å…‰ */
}

/* äº®è‰²æ¨¡å¼ Hover */
[data-theme="light"] .btn-spin:hover:not(:disabled) {
  background: linear-gradient(180deg, #4aa3df 0%, #1a75b3 100%);
  box-shadow:
    0 0 0 2px #dcdcdc,
    0 6px 12px rgba(0, 101, 179, 0.3),
    inset 0 2px 3px rgba(255, 255, 255, 0.6);
  transform: translateY(-2px);
}

/* äº®è‰²æ¨¡å¼ Active */
[data-theme="light"] .btn-spin:active {
  background: linear-gradient(180deg, #0e639c 0%, #0c4f7f 100%);
  box-shadow:
    0 0 0 2px #dcdcdc,
    0 2px 4px rgba(0, 0, 0, 0.2),
    inset 0 3px 5px rgba(0, 0, 0, 0.3);
  transform: translateY(1px);
}

.btn-square {
  width: 36px;
  height: 36px;
  font-size: 20px;
  background: var(--bg-input);
  border: 1px solid var(--border-color);
  color: var(--text-primary);
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 4px;
}
.btn-square:hover {
  background: var(--bg-hover);
}

/* --- ğŸ”¥ å³å´é¢æ¿ (Settings) ç„¡ç¸«èåˆç‰ˆ ğŸ”¥ --- */
.right-panel {
  border-right: none;
  border-left: 1px solid var(--border-color);
  padding: 12px;
  display: flex;
  flex-direction: column;
  gap: 10px;
  /* ğŸ”¥ é—œéµï¼šä½¿ç”¨è·Ÿå·¦å´ä¸€æ¨£çš„èƒŒæ™¯è‰²ï¼Œæ¶ˆé™¤æ–‘é¦¬ç´‹ */
  background: var(--bg-panel);
  overflow-y: auto;
}

.control-card {
  /* ğŸ”¥ é—œéµï¼šèƒŒæ™¯é€æ˜ï¼Œåªç•™é‚Šæ¡† */
  background: transparent;
  border: 1px solid var(--border-color);
  border-radius: 4px;
  overflow: hidden;
}

.panel-section {
  display: flex;
  flex-direction: column;
  gap: 0;
}

.card-header {
  background: var(--bg-card-header);
  padding: 5px 10px;
  border-bottom: 1px solid var(--border-color);
}

.card-title {
  font-size: 11px;
  font-weight: 700;
  color: var(--text-secondary);
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.card-body {
  padding: 10px;
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.action-area,
.quick-btns,
.dropdown-row {
  display: flex;
  gap: 8px;
}

/* è¼¸å…¥æ¡† */
.input-group label {
  font-size: 11px;
  color: var(--text-secondary);
  margin-bottom: 3px;
  display: block;
}

.custom-input,
.custom-select {
  width: 100%;
  background: var(--bg-input);
  border: 1px solid var(--border-color);
  color: var(--text-primary);
  padding: 0 8px;
  border-radius: 4px;
  outline: none;
  height: 28px;
  font-size: 13px;
}
.custom-input:focus,
.custom-select:focus {
  border-color: var(--accent-blue);
}
.custom-select {
  flex: 1;
}

.grid-2-col {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px;
}

/* è¼¸å…¥åˆ— (Volatility) */
.input-row {
  display: flex;
  align-items: center;
  gap: 8px;
}
.input-row .custom-input {
  flex: 1;
  text-align: right;
}
.suffix-label {
  font-size: 11px;
  color: var(--text-secondary);
  white-space: nowrap;
  width: 60px;
  text-align: left;
  margin-left: 2px;
}

/* æŒ‰éˆ•è®Šé«” */
.full-width {
  width: 100%;
}

.btn-primary {
  background: var(--accent-blue);
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  transition: background 0.1s;
}
.btn-primary:hover {
  background: var(--accent-blue-hover);
}

.btn-secondary {
  background: var(--bg-input);
  color: var(--text-primary);
  border: 1px solid var(--border-color);
  border-radius: 4px;
  cursor: pointer;
  transition: background 0.1s;
}
.btn-secondary:hover {
  background: var(--bg-hover);
}

.btn-block {
  flex: 1;
  font-weight: 600;
  font-size: 12px;
  text-align: center;
  padding: 0;
  height: 28px;
  line-height: 28px;
}

.btn-action {
  background: var(--accent-blue);
  color: white;
  border: none;
  border-radius: 4px;
  padding: 0 14px;
  cursor: pointer;
  font-weight: 600;
  font-size: 12px;
  height: 28px;
  white-space: nowrap;
}
.btn-action:hover {
  background: var(--accent-blue-hover);
}
.btn-action:disabled {
  background: var(--bg-input);
  color: var(--text-secondary);
  border: 1px solid var(--border-color);
  cursor: not-allowed;
}

.btn-xs {
  padding: 1px 8px;
  font-size: 11px;
  background: var(--bg-input);
  color: var(--text-secondary);
  border: 1px solid var(--border-color);
  border-radius: 3px;
  cursor: pointer;
}
.btn-xs:hover {
  color: var(--text-primary);
  border-color: var(--text-primary);
}

/* ğŸ”¥ğŸ”¥ğŸ”¥ é–ƒé›»æŒ‰éˆ•å„ªåŒ–ç‰ˆ (é­”å¹»ç´«) ğŸ”¥ğŸ”¥ğŸ”¥ */
.btn-lightning {
  display: flex;
  justify-content: center;
  align-items: center;
  
  /* ä¿®æ”¹èƒŒæ™¯ï¼šæ”¹ç”¨æ·±ç´«è‰²æ¼¸å±¤ï¼Œè®“é»ƒè‰²é–ƒé›»è·³å‡ºä¾† */
  background: linear-gradient(135deg, #7c3aed, #5b21b6);
  
  color: white;
  border: none;
  border-radius: 4px;
  font-weight: bold;
  font-size: 13px;
  cursor: pointer;
  
  /* ç´«è‰²ç³»é™°å½± */
  box-shadow: 0 2px 4px rgba(124, 58, 237, 0.4);
  
  transition: transform 0.1s;
  height: 32px;
}

.btn-lightning:hover {
  transform: translateY(-1px);
  /* Hover æ™‚è®Šäº®ä¸€é» */
  background: linear-gradient(135deg, #8b5cf6, #6d28d9);
}

.btn-lightning:active {
  transform: translateY(1px);
}

/* Helper classes */
.btn-sm {
  height: 28px;
  line-height: 28px;
  font-size: 12px;
}
.input-sm,
.select-sm,
.btn-sm-action {
  height: 28px;
  font-size: 12px;
}
.input-row.dense {
  gap: 6px;
  margin-bottom: 0;
}

/* Mode Buttons (Prizes) */
.mode-btn-group {
  display: flex;
  flex-direction: column;
  gap: 5px;
}
.mode-btn {
  background: var(--bg-input);
  border: 1px solid var(--border-color);
  color: var(--text-secondary);
  padding: 5px 10px;
  font-size: 12px;
  text-align: left;
  cursor: pointer;
  border-radius: 4px;
  transition: all 0.1s;
}
.mode-btn:hover {
  background: var(--bg-hover);
  color: var(--text-primary);
}
.mode-btn.active {
  background: var(--accent-blue);
  color: white;
  border-color: var(--accent-blue);
  font-weight: bold;
}

/* ğŸ”¥ ä¸»é¡Œåˆ‡æ›æŒ‰éˆ• */
.theme-toggle-btn {
  background: transparent;
  border: none;
  cursor: pointer;
  font-size: 16px;
  padding: 0 4px;
  line-height: 1;
  border-radius: 4px;
  transition:
    transform 0.2s,
    background-color 0.2s;
}
.theme-toggle-btn:hover {
  background-color: var(--bg-hover);
  transform: scale(1.1);
}

/* æ»¾å‹•æ¢ */
.custom-scrollbar::-webkit-scrollbar {
  width: 8px;
}
.custom-scrollbar::-webkit-scrollbar-track {
  background: var(--bg-app);
}
.custom-scrollbar::-webkit-scrollbar-thumb {
  background: #444;
  border-radius: 4px;
}
.custom-scrollbar::-webkit-scrollbar-thumb:hover {
  background: #555;
}

/* ğŸ”¥ğŸ”¥ğŸ”¥ System Actions ç·Šæ¹Šå–®è¡Œç‰ˆ CSS ğŸ”¥ğŸ”¥ğŸ”¥ */

/* å¤–å±¤å®¹å™¨ï¼šæ°´å¹³æ’åˆ—ï¼Œå‚ç›´ç½®ä¸­ï¼Œè¨­å®šé–“è· */
.system-compact-row {
  display: flex;
  align-items: center;
  gap: 8px; /* å…ƒä»¶ä¹‹é–“çš„é–“è· */
  height: 32px; /* ğŸ”¥ ç¨å¾®å¢åŠ é«˜åº¦ï¼Œçµ¦ä¸€é»å‘¼å¸ç©ºé–“ */
  padding: 2px 0;
}

/* é–‹é—œçµ„åˆï¼šæŠŠæ–‡å­—æ¨™ç±¤å’Œé–‹é—œç¶åœ¨ä¸€èµ· */
.compact-switch-group {
  display: flex;
  align-items: center;
  gap: 4px; /* æ¨™ç±¤è·Ÿé–‹é—œä¹‹é–“çš„é–“è· */
  white-space: nowrap; /* é˜²æ­¢æ¨™ç±¤æ›è¡Œ */
}

/* è¤‡ç”¨ä¹‹å‰çš„æ¨™ç±¤æ¨£å¼ï¼Œç¨å¾®èª¿æ•´é‚Šè· */
.switch-label {
  font-size: 11px;
  font-weight: 700; /* åŠ ç²—ä¸€é»é» */
  color: var(--text-secondary);
  opacity: 0.9; /* ç¨å¾®äº®ä¸€é»ï¼Œæ¯”è¼ƒå¥½è®€ */
  margin-right: 2px;
}

/* è¤‡ç”¨ä¹‹å‰çš„ Toggle Switch å°å°ºå¯¸æ¨£å¼ */
.toggle-switch.small {
  position: relative;
  display: inline-block;
  width: 30px;
  height: 16px;
  flex-shrink: 0; /* é˜²æ­¢é–‹é—œè¢«å£“ç¸® */
}

/* éš±è—åŸå§‹ checkbox */
.toggle-switch input {
  opacity: 0;
  width: 0;
  height: 0;
}

/* æ»‘è»Œ */
.slider {
  position: absolute;
  cursor: pointer;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: #555; /* æ·±è‰²æ¨¡å¼é è¨­ç° */
  transition: 0.3s;
  border-radius: 20px;
}

/* äº®è‰²æ¨¡å¼å¾®èª¿ */
[data-theme="light"] .slider {
  background-color: #ccc;
}

/* åœ“éˆ• */
.slider:before {
  position: absolute;
  content: "";
  height: 12px; /* åŸæœ¬ 16px */
  width: 12px; /* åŸæœ¬ 16px */
  left: 2px;
  bottom: 2px;
  background-color: white;
  transition: 0.3s;
  border-radius: 50%;
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
}

/* é–‹å•Ÿç‹€æ…‹ (Checked) */
.toggle-switch input:checked + .slider {
  background-color: var(--accent-blue);
}

/* åœ“éˆ•ç§»å‹• */
.toggle-switch input:checked + .slider:before {
  transform: translateX(14px); /* é…åˆç¸®å°çš„å¯¬åº¦èª¿æ•´ä½ç§» */
}
--- END OF FILE: src\styles\dashboard.css ---

--- START OF FILE: src\styles\report.css ---
/* src/styles/report.css */

/* å ±è¡¨å®¹å™¨ */
.report-container {
  padding: 10px;
  display: flex;
  flex-direction: column;
  gap: 15px;
  overflow-y: auto;
  height: 100%;
}

/* å¡ç‰‡å¤–æ¡† */
.section-card {
  background: var(--bg-panel);
  border: 1px solid var(--border-color);
  border-radius: 4px;
  overflow: hidden;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

/* å¡ç‰‡æ¨™é¡Œåˆ— */
.section-header {
  background: var(--bg-panel-header);
  padding: 8px 12px;
  cursor: pointer;
  display: flex;
  align-items: center;
  border-bottom: 1px solid var(--border-color);
  user-select: none;
  transition: background 0.2s;
}
.section-header:hover {
  background: var(--bg-hover);
}
.section-header .title {
  font-weight: bold;
  font-size: 13px;
  color: var(--text-primary);
}
.toggle-icon {
  margin-right: 8px;
  font-size: 10px;
  color: var(--text-secondary);
  width: 12px;
  text-align: center;
}

/* å¡ç‰‡å…§å®¹å€ */
.section-body {
  padding: 15px;
  background: var(--bg-app);
}

/* ä¸‰æ¬„ä½ˆå±€ (Grid System) */
.grid-3-col {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 15px;
}

/* çµ±è¨ˆå°æ–¹å¡Š (Stat Box) */
.stat-box {
  background: var(--bg-panel);
  border: 1px solid var(--border-color);
  border-radius: 4px;
  padding: 0;
  overflow: hidden;
}
.stat-box.empty {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  color: var(--text-secondary);
  min-height: 200px;
}
.box-title {
  background: var(--bg-card-header);
  padding: 6px 10px;
  font-size: 12px;
  font-weight: bold;
  border-bottom: 1px solid var(--border-color);
  color: var(--text-primary);
  text-align: center;
}

/* æ•¸æ“šè¡¨æ ¼ (Data Table - key/value å‹) */
.data-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 12px;
}
.data-table td {
  padding: 5px 10px;
  border-bottom: 1px solid var(--border-color);
  color: var(--text-secondary);
}
.data-table td:nth-child(2) {
  text-align: right;
  color: var(--text-primary);
  font-weight: 500;
  font-family: 'Consolas', monospace;
}
.data-table tr:last-child td {
  border-bottom: none;
}
.data-table tr.highlight td {
  color: var(--accent-blue);
  font-weight: bold;
  background: rgba(14, 99, 156, 0.1); /* ä½¿ç”¨ä¸»é¡Œè‰² */
}

/* å¯¬ç‰ˆåˆ—è¡¨æ ¼ (Full Width Table - list å‹) */
.full-width-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 12px;
  border: 1px solid var(--border-color);
}
.full-width-table th, .full-width-table td {
  padding: 6px 10px;
  border: 1px solid var(--border-color);
  text-align: center;
}
.full-width-table th {
  background: var(--bg-card-header);
  color: var(--text-primary);
  font-weight: bold;
}
.full-width-table td {
  color: var(--text-secondary);
  font-family: 'Consolas', monospace;
}
/* æ–‘é¦¬ç´‹ */
.full-width-table tr:nth-child(even) {
  background: rgba(255, 255, 255, 0.02);
}
.full-width-table tr:hover {
  background: var(--bg-hover);
  color: var(--text-primary);
}
--- END OF FILE: src\styles\report.css ---

--- START OF FILE: src\styles\slot-machine.css ---
.slot-machine-container {
  position: relative;
  display: inline-block;
  padding: 10px;
  background: #000; /* æ©Ÿå™¨åº•è‰² */
  border-radius: 8px;
  border: 2px solid #555;
  box-shadow: inset 0 0 10px #000;
}

.reel-frame {
  display: flex; /* è®“ Reel å·¦å³æ’åˆ— */
  gap: 4px;      /* Reel ä¹‹é–“çš„é–“è· */
}

.reel-col {
  display: flex;
  flex-direction: column; /* Reel å…§éƒ¨ä¸Šä¸‹æ’åˆ— */
  gap: 4px;               /* Symbol ä¹‹é–“çš„é–“è· */
}

/* è½‰å‹•æ™‚çš„å‹•æ…‹æ•ˆæœ (æ¨¡ç³Š) */
.spinning .reel-col {
  filter: blur(4px);
  transform: scale(0.98);
  opacity: 0.7;
  transition: all 0.2s;
}

.symbol-cell {
  position: relative;
  /* ğŸ”¥ ä¿®æ”¹é€™è£¡ï¼šåŠ å¤§å°ºå¯¸ */
  width: 110px;  /* åŸæœ¬ 80px */
  height: 95px;  /* åŸæœ¬ 70px */
  background: #222;
  border-radius: 6px;
  overflow: hidden; 
  border: 1px solid #333;
}

.symbol-inner {
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 24px;
  font-family: 'Arial Black', sans-serif; /* ç²—é«”å­—å‹ */
}

/* å³ä¸‹è§’çš„åº§æ¨™ Debug é¡¯ç¤º */
.coord-debug {
  position: absolute;
  bottom: 2px;
  right: 3px;
  font-size: 9px;
  color: #444;
  pointer-events: none;
  font-family: monospace;
}

/* é®ç½©å±¤ */
.spin-overlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.2);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 10;
  backdrop-filter: blur(1px);
}

.loading-text {
  color: #00ff00;
  font-weight: bold;
  font-family: monospace;
  background: rgba(0,0,0,0.8);
  padding: 5px 10px;
  border-radius: 4px;
}

.symbol-inner {
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  background: #222; /* åœ–ç‰‡é€æ˜æ™‚çš„åº•è‰² */
  position: relative;
}

/* æ–°å¢åœ–ç‰‡æ¨£å¼ */
.symbol-img {
  width: 90%;       /* ç•™ä¸€é»é‚Šè· */
  height: 90%;
  object-fit: contain; /* ç¢ºä¿åœ–ç‰‡æ¯”ä¾‹ä¸è®Šï¼Œå®Œæ•´é¡¯ç¤º */
  display: block;
}

/* å¦‚æœæœ‰åŠ  ID ç–ŠåŠ å±¤ */
.id-overlay {
  position: absolute;
  top: 0;
  left: 0;
  font-size: 10px;
  color: rgba(255, 255, 255, 0.5);
  padding: 2px;
  background: rgba(0,0,0,0.5);
}

/* ... (åŸæœ¬çš„ CSS ä¿æŒä¸è®Š) ... */

/* ğŸ”¥ æ–°å¢ä¸­çå‹•ç•« */
@keyframes win-pulse {
  0% { box-shadow: 0 0 0 0 rgba(255, 215, 0, 0.7); border-color: gold; }
  50% { box-shadow: 0 0 15px 5px rgba(255, 215, 0, 0.3); border-color: #fff; transform: scale(1.05); }
  100% { box-shadow: 0 0 0 0 rgba(255, 215, 0, 0); border-color: gold; transform: scale(1); }
}

.symbol-cell.win-anim {
  z-index: 10; /* ç¢ºä¿ç‰¹æ•ˆè“‹åœ¨æœ€ä¸Šå±¤ */
  border: 2px solid gold !important;
  animation: win-pulse 1s infinite;
  background-color: rgba(255, 215, 0, 0.2);
}
--- END OF FILE: src\styles\slot-machine.css ---

--- START OF FILE: src\vite-env.d.ts ---
/// <reference types="vite/client" />

--- END OF FILE: src\vite-env.d.ts ---

--- START OF FILE: electron\electron-env.d.ts ---
/// <reference types="vite-plugin-electron/electron-env" />

declare namespace NodeJS {
  interface ProcessEnv {
    /**
     * The built directory structure
     *
     * ```tree
     * â”œâ”€â”¬â”€â”¬ dist
     * â”‚ â”‚ â””â”€â”€ index.html
     * â”‚ â”‚
     * â”‚ â”œâ”€â”¬ dist-electron
     * â”‚ â”‚ â”œâ”€â”€ main.js
     * â”‚ â”‚ â””â”€â”€ preload.js
     * â”‚
     * ```
     */
    APP_ROOT: string
    /** /dist/ or /public/ */
    VITE_PUBLIC: string
  }
}

// Used in Renderer process, expose in `preload.ts`
interface Window {
  ipcRenderer: import('electron').IpcRenderer
}

--- END OF FILE: electron\electron-env.d.ts ---

--- START OF FILE: electron\gameService.ts ---
import { app } from 'electron';
import path from 'path';
import { createRequire } from 'module';
import { fileURLToPath } from 'url';

// å»ºç«‹ require ç’°å¢ƒ
const require = createRequire(import.meta.url);
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
class GameService {
  private slotRand: any = null;
  public config: any = null; // æ”¹æˆ public æ–¹ä¾¿å¤–éƒ¨è®€å–

  constructor() {
    this.init();
  }

  getGameConfig() {
    if (!this.config) {
      return { error: "Config not loaded" };
    }

    let coreInfo: any = {};
    if (this.slotRand && typeof this.slotRand.getInfo === 'function') {
      coreInfo = this.slotRand.getInfo();
    }

    // æˆ‘å€‘åªå›å‚³å‰ç«¯éœ€è¦çš„è³‡è¨Šï¼Œä¸éœ€è¦æŠŠæ•´å€‹é¾å¤§çš„ config ä¸Ÿéå»
    return {
      paylines: this.config.paylines || [], // é€™æ˜¯é—œéµï¼å¾ xls/json è®€ä¾†çš„
      lineCount: this.config.line_count,
      window: this.config.window, // ç›¤é¢å¤§å° (5x3)
      paytable: this.config.paytable, // (é¸ç”¨) å¦‚æœä½ æƒ³åœ¨å‰ç«¯é¡¯ç¤ºè³ ç‡è¡¨
      buyFeatureInfos: coreInfo.buyFeatureInfos || {}
    };
  }

  init() {
    console.log('[GameService] Initializing...');

    // è¨ˆç®— rand-core è·¯å¾‘
    // æŠ€å·§ï¼š__dirname åœ¨é–‹ç™¼æ¨¡å¼ä¸‹æ˜¯ .../dist-electron
    // æˆ‘å€‘è¦æ‰¾çš„æ˜¯ .../electron/rand-core/index.js
    const libraryPath = !app.isPackaged
      ? path.resolve(__dirname, '../electron/rand-core/index.js')
      : path.join(process.resourcesPath, 'rand-core/index.js');

    console.log('[GameService] Target Core Path:', libraryPath);

    try {
      // å˜—è©¦è¼‰å…¥æ¨¡çµ„
      const RandCore = require(libraryPath);

      // å˜—è©¦å¯¦ä¾‹åŒ–
      const randInstance = RandCore();

      if (randInstance) {
        this.slotRand = randInstance;
        this.config = this.slotRand.rand?.define || {};
        console.log('[GameService] Core Loaded Successfully!');
        console.log('[GameService] Line Count:', this.config.line_count || 'Unknown');
      } else {
        console.error('[GameService] RandCore() returned null/undefined');
      }

    } catch (e: any) {
      console.error('[GameService] CRITICAL ERROR:', e.message);
      // å°å‡º Stack Trace æ–¹ä¾¿é™¤éŒ¯
      console.error(e.stack);
    }
  }

  spin(betInfo: any, sysState: any) {
    if (!this.slotRand) {
      console.error('[GameService] Spin failed: Core not initialized');
      return { error: "Core not initialized" };
    }

    try {
      const result = this.slotRand.getSpinResult(betInfo, sysState, {}, {});
      console.log(JSON.stringify(result));
      
      return result;
    } catch (e: any) {
      console.error('[GameService] Spin Logic Error:', e);
      return { error: e.message };
    }
  }
}

export default new GameService();
--- END OF FILE: electron\gameService.ts ---

--- START OF FILE: electron\main.ts ---
import { app, BrowserWindow, dialog, ipcMain, shell } from 'electron'
import { fileURLToPath } from 'url'
import path from 'path'
import fs from 'fs'
import GameService from './gameService.js'
import { createRequire } from 'module'; // å¼•å…¥ createRequire
import fse from 'fs-extra';
import AdmZip from 'adm-zip'
import { StatsManager } from './simulation/stats/StatsManager.js'

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// ğŸ”¥ é€™ä¸€è¡Œéå¸¸é‡è¦ï¼Œå®ƒå®šç¾©äº†å°ˆæ¡ˆæ ¹ç›®éŒ„
process.env.APP_ROOT = path.join(__dirname, '..');

// ğŸ”¥ ä¿®æ­£å¾Œçš„ require
const require = createRequire(import.meta.url);
const parserServicePath = path.join(process.env.APP_ROOT, 'electron/rand-core/parser/parserService.js');
const ParserService = require(parserServicePath);
const workerpool = require('workerpool');
// ... (å¾Œé¢çš„è®Šæ•¸å®šç¾©)
export const VITE_DEV_SERVER_URL = process.env['VITE_DEV_SERVER_URL']
export const MAIN_DIST = path.join(process.env.APP_ROOT, 'dist-electron')
export const RENDERER_DIST = path.join(process.env.APP_ROOT, 'dist')
process.env.VITE_PUBLIC = VITE_DEV_SERVER_URL ? path.join(process.env.APP_ROOT, 'public') : RENDERER_DIST

const workerPath = path.join(process.env.APP_ROOT, 'dist-electron/worker.js');
let pool: any = null;

function initPool() {
  if (pool) return; // å·²ç¶“æœ‰å°±ä¸ç”¨å»º
  pool = workerpool.pool(workerPath, { maxWorkers: 10 });
}

let reportCache: any = null;
let reportConfigCache: any = null;
let progressWin: BrowserWindow | null = null; // å­˜è®€æ¢è¦–çª—

let win: BrowserWindow | null

type betInfo = {
  /** æŠ¼æ³¨ç­‰ç´š */
  betlv: number;
  /** ç·šä¸‹æ³¨é¡ */
  lineBet: number;
  /** ç·šæ•¸é¸æ“‡æ•¸é‡ */
  lineSelect: number;
  /** è³¼è²·ç‰¹è‰²éŠæˆ²é¡å‹ */
  buyFeatureType?: number;
  betValue?: number;
}

type SysInfo = {
  /** æŒ‡å®šRTP */
  targetRTP?: number;
  /** æŒ‡å®šè´åˆ†é™ç´… */
  targetWinLimit?: number;
  targetPrizeType?: number;
  randMode?: string;
};

function loadStatConfig() {
  try {
    // å®šç¾©è·¯å¾‘ï¼š
    // é–‹ç™¼æ¨¡å¼: å°ˆæ¡ˆæ ¹ç›®éŒ„/electron/setting/config.json
    // æ‰“åŒ…æ¨¡å¼: resources/setting/config.json (éœ€è¦åœ¨ builder config è¨­å®šï¼Œç¨å¾Œèªªæ˜)
    const configPath = app.isPackaged
      ? path.join(process.resourcesPath, 'setting', 'config.json')
      : path.join(process.env.APP_ROOT, 'electron', 'setting', 'config.json');

    // console.log('[Main] Loading Stat Config from:', configPath);

    if (fs.existsSync(configPath)) {
      const data = fs.readFileSync(configPath, 'utf-8');
      return JSON.parse(data);
    }
  } catch (e) {
    console.error('[Main] Error loading stat config:', e);
  }
}

function loadGameSpec() {
  try {
    const specPath = path.join(process.env.APP_ROOT, 'electron/rand-core/config/spec.json');
    if (fs.existsSync(specPath)) {
      const data = fs.readFileSync(specPath, 'utf-8');
      return JSON.parse(data);
    }
  } catch (e) {
    console.error('Error loading spec.json:', e);
  }
  return { name: 'Slot Machine Simulator' };
}

function createProgressWindow() {
  if (progressWin) return; // é¿å…é‡è¤‡é–‹

  progressWin = new BrowserWindow({
    width: 400,  // è¨­å®šå°å°ºå¯¸
    height: 400,
    frame: false, // ğŸ”¥ ç„¡é‚Šæ¡† (é€™æ¨£æ‰åƒè‡ªè¨‚ UI)
    resizable: false, // ç¦æ­¢ç¸®æ”¾
    alwaysOnTop: true, // ğŸ”¥ æ°¸é ç½®é ‚ (ä½¿ç”¨è€…åˆ‡å»å…¶ä»–è¦–çª—ä¹Ÿèƒ½çœ‹åˆ°é€²åº¦)
    webPreferences: {
      preload: path.join(__dirname, 'preload.mjs'),
    },
  });

  // è¼‰å…¥ Progress é é¢
  if (VITE_DEV_SERVER_URL) {
    const url = VITE_DEV_SERVER_URL.endsWith('/') ? VITE_DEV_SERVER_URL : `${VITE_DEV_SERVER_URL}/`;
    progressWin.loadURL(`${url}#progress`);
  } else {
    progressWin.loadFile(path.join(RENDERER_DIST, 'index.html'), { hash: 'progress' });
  }

  progressWin.on('closed', () => { progressWin = null; });
}

function createWindow() {

  const spec = loadGameSpec();
  const gameName = spec.name || 'Slot Machine Simulator';

  win = new BrowserWindow({
    width: 1200,
    height: 850,
    title: gameName,
    autoHideMenuBar: false,
    icon: path.join(process.env.VITE_PUBLIC, 'electron-vite.svg'),
    webPreferences: {
      preload: path.join(__dirname, 'preload.mjs'),
    },
  })

  win.webContents.on('did-finish-load', () => {
    const currentSpec = loadGameSpec();
    const title = currentSpec.name || 'Slot Machine Simulator';
    win?.webContents.send('sys:update-title', title);
  });

  win.webContents.on('did-finish-load', () => {
    win?.webContents.send('main-process-message', (new Date).toLocaleString())
  })

  if (VITE_DEV_SERVER_URL) {
    win.loadURL(VITE_DEV_SERVER_URL)
  } else {
    win.loadFile(path.join(RENDERER_DIST, 'index.html'))
  }
}

// --- App å•Ÿå‹•é‚è¼¯ (åˆä½µç‰ˆ) ---
app.whenReady().then(() => {
  console.log('[Main] App is ready, initializing services...');
  // ğŸ”¥ æ–°å¢ç›£è½ï¼šåˆå§‹åŒ–è«‹æ±‚
  ipcMain.handle('game:init', async () => {
    const config = GameService.getGameConfig();
    return config;
  });
  // 1. è¨­å®š IPC ç›£è½
  ipcMain.handle('game:spin', async (_event, spinInfo) => {

    // ç°¡å–®çš„åƒæ•¸è½‰æ›
    const betInfo: betInfo = { betlv: spinInfo.betLv, lineBet: spinInfo.lineBet, lineSelect: 25, buyFeatureType: spinInfo.buyFeatureType };
    const sysState: SysInfo = {
      targetRTP: spinInfo.targetRTP,
      targetWinLimit: spinInfo.targetWinLimit,
      targetPrizeType: spinInfo.targetPrizeType,
      randMode: spinInfo.randMode
    };
    console.log('[Main] Spin Request', JSON.stringify(betInfo), JSON.stringify(sysState));

    // å‘¼å« Service
    const result = GameService.spin(betInfo, sysState);
    return result;
  });

  ipcMain.handle('system:open-file', async (_event, fileName) => {
    try {
      // 1. å®šç¾© xls æ ¹ç›®éŒ„ä½ç½®
      // é–‹ç™¼æ¨¡å¼ä¸‹ï¼Œprocess.cwd() é€šå¸¸æ˜¯å°ˆæ¡ˆæ ¹ç›®éŒ„
      const rootDir = process.cwd();

      // 2. çµ„åˆå®Œæ•´è·¯å¾‘ (å°æ‡‰åˆ° xls/config-game/...)
      const filePath = path.join(rootDir, 'xls', 'config-game', fileName);

      console.log('[Main] Opening file:', filePath);

      // 3. ä½¿ç”¨ç³»çµ±é è¨­ç¨‹å¼é–‹å•Ÿ (æœƒå–šé†’ Excel)
      const error = await shell.openPath(filePath);

      if (error) {
        console.error('[Main] Open Error:', error);
        return { success: false, error };
      }
      return { success: true };
    } catch (e: any) {
      console.error('[Main] System Error:', e);
      return { success: false, error: e.message };
    }
  });

  ipcMain.handle('system:get-excel-files', async () => {
    try {
      const rootDir = path.join(process.cwd(), 'xls', 'config-game');

      // éè¿´æƒæå‡½å¼
      const getFilesRecursively = (dir: string, fileList: string[] = []) => {
        const files = fs.readdirSync(dir);
        files.forEach(file => {
          const filePath = path.join(dir, file);
          const stat = fs.statSync(filePath);

          if (stat.isDirectory()) {
            getFilesRecursively(filePath, fileList);
          } else {
            // åªæŠ“ xls æª”
            if (file.endsWith('.xls')) {
              // è½‰æˆç›¸å°è·¯å¾‘ (ä¾‹å¦‚: "default/plate_990.xls")
              const relativePath = path.relative(rootDir, filePath);
              // çµ±ä¸€åˆ†éš”ç¬¦è™Ÿç‚º / (é¿å… Windows åæ–œç·šå•é¡Œ)
              fileList.push(relativePath.replace(/\\/g, '/'));
            }
          }
        });
        return fileList;
      };

      if (!fs.existsSync(rootDir)) {
        return [];
      }

      const files = getFilesRecursively(rootDir);
      return files.sort(); // æ’åºä¸€ä¸‹æ¯”è¼ƒå¥½æ‰¾
    } catch (e) {
      console.error('[Main] Scan Error:', e);
      return [];
    }
  });

  ipcMain.handle('system:reload', async () => {
    try {
      console.log('[Main] Reloading System...');

      // 1. åŸ·è¡Œ Excel è½‰æª” (Parser)
      // é è¨­è·¯å¾‘é€šå¸¸æ˜¯å°ˆæ¡ˆæ ¹ç›®éŒ„ä¸‹çš„ xls è³‡æ–™å¤¾ï¼Œé€™è£¡å‡è¨­ä½ çš„çµæ§‹
      const rootDir = process.cwd();
      const xlsDir = path.join(rootDir, 'xls');

      console.log('[Main] Parsing Excel from:', xlsDir);
      ParserService.parse(xlsDir); // é€™æœƒé‡æ–°ç”¢ç”Ÿ JSON åˆ° config è³‡æ–™å¤¾

      // 2. é‡æ–°åˆå§‹åŒ– GameService (é‡æ–°è®€å– JSON)
      GameService.init();

      console.log('[Main] Reload Complete.');
      const newSpec = loadGameSpec();
      const newTitle = newSpec.name || 'Slot Machine Simulator';

      if (win) win.setTitle(newTitle);

      if (win) win.webContents.send('sys:update-title', newTitle);
      return { success: true };
    } catch (e: any) {
      console.error('[Main] Reload Error:', e);
      return { success: false, error: e.message };
    }
  });
  ipcMain.handle('window:minimize-progress', () => {
    if (progressWin) {
      progressWin.minimize();
    }
    return { success: true };
  });
  ipcMain.handle('system:export', async (_event, options = {}) => {
    try {
      // 1. è®€å–éŠæˆ²åç¨± (æ±ºå®šåŒ¯å‡ºè³‡æ–™å¤¾çš„åå­—)
      const { useZip, exportSource } = options;
      const spec = loadGameSpec();
      const exportFolderName = spec.name || 'Slot-Game-Export'; // é è¨­åç¨±

      console.log(`[Main] Exporting Game: ${exportFolderName}`, options);

      // 2. å®šç¾©ä¾†æºè·¯å¾‘ (ä½ çš„ rand-core ä½ç½®)
      const sourcePath = path.join(process.env.APP_ROOT, 'electron/rand-core');

      // 3. é–‹å•Ÿè³‡æ–™å¤¾é¸æ“‡æ¡†
      const result = await dialog.showOpenDialog({
        title: `åŒ¯å‡º ${exportFolderName}`,
        buttonLabel: 'åŒ¯å‡ºè‡³æ­¤',
        properties: ['openDirectory', 'createDirectory']
      });

      // å¦‚æœä½¿ç”¨è€…æŒ‰å–æ¶ˆ
      if (result.canceled || result.filePaths.length === 0) {
        return { success: false, cancelled: true };
      }

      const saveRootDir = result.filePaths[0];
      // çµ„åˆæœ€çµ‚è·¯å¾‘ï¼šä½¿ç”¨è€…é¸çš„ç›®éŒ„ + éŠæˆ²åç¨±
      const destPath = path.join(saveRootDir, exportFolderName);

      // 4. ç¢ºä¿ç›®æ¨™ä¹¾æ·¨ (å¦‚æœå·²å­˜åœ¨è©²è³‡æ–™å¤¾ï¼Œå…ˆåˆªé™¤)
      if (fse.existsSync(destPath)) {
        console.log('[Main] Target exists, cleaning up...');
        fse.removeSync(destPath);
      }

      console.log(`[Main] Copying from ${sourcePath} to ${destPath}`);

      // 5. å®šç¾©éæ¿¾è¦å‰‡ (åƒè€ƒä½ æä¾›çš„ Regex)
      // æ’é™¤ï¼šéš±è—æª”(ä»¥.é–‹é ­)ã€parserç›¸é—œã€devç›¸é—œã€ä»¥åŠ node_modules
      const excludeReg = new RegExp("(.+/[\\.].+)|node_modules|parser|dev|ts-node|package\\.json");

      // 6. åŸ·è¡Œè¤‡è£½
      fse.copySync(sourcePath, destPath, {
        filter: (src: string) => {
          // src æ˜¯ç•¶å‰è¦è¤‡è£½çš„æª”æ¡ˆå®Œæ•´è·¯å¾‘
          // çµ±ä¸€è½‰ç‚º unix style (/) é¿å… Windows åæ–œç·š (\) é€ æˆ regex èª¤åˆ¤
          const normalizedSrc = src.replace(/\\/g, '/');

          if (excludeReg.test(normalizedSrc)) {
            return false;
          }

          // å¯ä»¥åœ¨é€™è£¡åŠ  log ä¾†çœ‹è¤‡è£½äº†å“ªäº›æª”æ¡ˆ (é¸ç”¨)
          // console.log('Copying:', path.basename(src));
          return true;
        }
      });

      if (exportSource) {
        console.log('[Main] Copying Source XLS...');
        const xlsSourcePath = path.join(process.cwd(), 'xls', 'config-game');
        const xlsDestPath = path.join(destPath, 'config-game-source');

        // ç¢ºä¿ä¾†æºå­˜åœ¨
        if (fse.existsSync(xlsSourcePath)) {
          // è¤‡è£½æ•´å€‹è³‡æ–™å¤¾ï¼Œä½†æ’é™¤éš±è—æª”
          fse.copySync(xlsSourcePath, xlsDestPath, {
            filter: (src: string) => !src.includes('/.') && !src.includes('\\.')
          });
        } else {
          console.warn('[Main] Source XLS path not found:', xlsSourcePath);
        }
      }

      if (useZip) {
        console.log('[Main] Zipping Config...');
        const configPath = path.join(destPath, 'config');
        const zipPath = path.join(destPath, 'config.zip');

        if (fse.existsSync(configPath)) {
          const zip = new AdmZip();
          // å°‡ config è³‡æ–™å¤¾å…§çš„å…§å®¹åŠ å…¥ zip
          zip.addLocalFolder(configPath);
          // å¯«å…¥ zip æª”æ¡ˆ
          zip.writeZip(zipPath);

          // (é¸ç”¨) å¦‚æœä½ å¸Œæœ›å£“ç¸®å¾Œåˆªé™¤åŸæœ¬çš„ config è³‡æ–™å¤¾ï¼Œè«‹æ‰“é–‹ä¸‹é¢é€™è¡Œï¼š
          // fse.removeSync(configPath); 
        }
      }

      console.log('[Main] Export Success!');

      // 7. åŒ¯å‡ºå®Œæˆå¾Œï¼Œè‡ªå‹•é–‹å•Ÿè©²è³‡æ–™å¤¾ï¼Œæ–¹ä¾¿ä½¿ç”¨è€…æŸ¥çœ‹
      shell.openPath(destPath);

      return { success: true, path: destPath };

    } catch (e: any) {
      console.error('[Main] Export Error:', e);
      return { success: false, error: e.message };
    }
  });

  // 4. æ–°å¢ï¼šè®“æ–°è¦–çª—ä¾†é ˜å–æ•¸æ“šçš„æŒ‡ä»¤
  ipcMain.handle('report:get-data', () => {
    return {
      result: reportCache,
      components: reportConfigCache
    };
  });

  ipcMain.handle('game:stop-lightning', async () => {
    if (pool) await pool.terminate(true);
    pool = null;
    // é—œé–‰è®€æ¢è¦–çª—
    if (progressWin) progressWin.close();
    return { success: true };
  });

  ipcMain.handle('game:lightning', async (_event, rawConfig) => {

    console.log('[Main] Starting Lightning Simulation...', rawConfig);
    createProgressWindow();
    initPool();
    const statConfig = loadStatConfig();
    const totalSpins = rawConfig.simConfig.rounds || 100000;
    const workerCount = 10;
    const spinsPerWorker = Math.floor(totalSpins / workerCount);
    const randCorePath = path.join(process.env.APP_ROOT, 'electron/rand-core/index.js');
    const config = GameService.getGameConfig();
    let rate = 1;
    const manager = new StatsManager({
      ...statConfig,
      exitInfo: {
        exitStart: rawConfig.exitInfo.exitStart,
        exitEnd: rawConfig.exitInfo.exitEnd,
        exitMaxWin: rawConfig.exitInfo.exitMaxWin
      }
    });

    const promises = [];
    const workerProgress = new Array(workerCount).fill(0);
    let completedWorkers = 0;

    if (rawConfig.simConfig.buyFeatureType !== undefined) {
      rate = config.buyFeatureInfos[rawConfig.simConfig.buyFeatureType]?.rate || 1;
    }
    for (let i = 0; i < workerCount; i++) {
      const input = {
        workerId: i,
        config: {
          lineCount: rawConfig.simConfig.lineCount,
          spinCount: spinsPerWorker,
          betAmount: rawConfig.simConfig.bets[rawConfig.simConfig.betlv],
          betLevel: rawConfig.simConfig.betlv,
          targetRTP: rawConfig.simConfig.targetRTP,
          buyFeatureType: rawConfig.simConfig.buyFeatureType,
          targetPrizeType: rawConfig.simConfig.targetPrizeType,
          targetWinLimit: rawConfig.simConfig.targetWinLimit,
          randMode: rawConfig.simConfig.randMode || 'default',
          components: statConfig.components,
        },
        chunkSize: spinsPerWorker,
        randCorePath: randCorePath
      };

      const p = pool.exec('runSimulation', [input], {
        on: (payload: any) => {
          if (payload.type === 'progress') {

            // 1. æ›´æ–°é€™ä½ Worker çš„é€²åº¦ (payload.processed æ˜¯è©² Worker ç›®å‰è·‘çš„è½‰æ•¸)
            workerProgress[payload.workerId] = payload.processed;

            // 2. ç´¯åŠ æ‰€æœ‰ Worker çš„é€²åº¦
            const totalDone = workerProgress.reduce((a, b) => a + b, 0);

            // 3. è¨ˆç®—å…¨åŸŸç™¾åˆ†æ¯” (ä¿ç•™å°æ•¸é»å¾Œå…©ä½)
            const globalPercent = Number(((totalDone / totalSpins) * 100).toFixed(2));

            if (progressWin && !progressWin.isDestroyed()) {
              progressWin.webContents.send('sys:sim-progress', {
                percentage: globalPercent,
                totalDone: totalDone,
                totalSpins: totalSpins
              });
            }
          }
        }
      }).then((result: any) => {
        // console.log(`[Main] Worker ${result.workerId} Finished.`);
        manager.merge(result.stats);
        workerProgress[result.workerId] = spinsPerWorker;
        completedWorkers++;
      }).catch((err: any) => {
        if (err.message === 'Terminated') {
          console.log(`[Main] Worker ${i} terminated.`);
        } else {
          console.error(`[Main] Worker ${i} error:`, err);
          throw err; // å…¶ä»–éŒ¯èª¤ç¹¼çºŒæ‹‹å‡º
        }
      });

      promises.push(p);
    }

    try {
      await Promise.all(promises);
      if (!pool) {
        return { success: false, error: 'Simulation Cancelled by User' };
      }
      const finalReport = manager.getFinalReport(rate);
      reportCache = finalReport;
      reportConfigCache = statConfig.components; // ä¹Ÿå­˜è¨­å®š
      if (progressWin) progressWin.close();

      const rWin = new BrowserWindow({ width: 1200, height: 850, autoHideMenuBar: false, webPreferences: { preload: path.join(__dirname, 'preload.mjs') } });
      if (VITE_DEV_SERVER_URL) {
        const url = VITE_DEV_SERVER_URL.endsWith('/') ? VITE_DEV_SERVER_URL : `${VITE_DEV_SERVER_URL}/`;
        rWin.loadURL(`${url}#report`);
      } else {
        rWin.loadFile(path.join(RENDERER_DIST, 'index.html'), { hash: 'report' });
      }

      return { success: true };

    } catch (e: any) {
      if (e.message === 'Terminated' || !pool) {
        return { success: false, cancelled: true };
      }
      console.error('[Main] Simulation Error:', e);
      return { success: false, error: e.message };
    }
  });
  createWindow();
})

app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit()
    win = null
  }
})

app.on('activate', () => {
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow()
  }
});
--- END OF FILE: electron\main.ts ---

--- START OF FILE: electron\preload.ts ---
import { ipcRenderer, contextBridge } from 'electron'

// --------- Expose some API to the Renderer process ---------
contextBridge.exposeInMainWorld('ipcRenderer', {
  on(...args: Parameters<typeof ipcRenderer.on>) {
    const [channel, listener] = args
    return ipcRenderer.on(channel, (event, ...args) => listener(event, ...args))
  },
  off(...args: Parameters<typeof ipcRenderer.off>) {
    const [channel, ...omit] = args
    return ipcRenderer.off(channel, ...omit)
  },
  send(...args: Parameters<typeof ipcRenderer.send>) {
    const [channel, ...omit] = args
    return ipcRenderer.send(channel, ...omit)
  },
  invoke(...args: Parameters<typeof ipcRenderer.invoke>) {
    const [channel, ...omit] = args
    return ipcRenderer.invoke(channel, ...omit)
  },

  // You can expose other APTs you need here.
  // ...
})

--- END OF FILE: electron\preload.ts ---

--- START OF FILE: electron\rand-core\config\default.json ---
{"high":{"main":{"s1":[0],"s2":{"0":[0]},"reels":{"0":{"0":["1.1","1.1","1.1","1.1","1.1","L1"]}},"respin":{"0":{"0":[null,null,null,null,-2,1,null,null]},"20":{}}},"free":{"freeState":{"0":[0],"1":[0],"2":[0],"3":[0]},"multipleRangeMap":{"0":{"min":null,"minChance":null,"max":null,"maxChance":null},"1":{"min":null,"minChance":null,"max":null,"maxChance":null},"2":{"min":null,"minChance":null,"max":null,"maxChance":null},"3":{"min":null,"minChance":null,"max":null,"maxChance":null},"4":{"min":null,"minChance":null,"max":null,"maxChance":null}},"s1":[[0],[0],[0],[0],[0]],"respin":{"0":{"0":null},"20":{}},"s2":{"0":[0]},"reels":{"0":{"0":["1","1","1","1","1","L1"]}}},"plateMaxWin":3000,"plateMaxWinFlag":false,"ridMap":{"1":"1","1.1":"1"},"strips":{"1":[2,1,3,23,5,5,6,6,9,9,3,5,6,7,7,7,9,5,8,2,10,7,7,3,1,1,10,6,7,2,2,10,10,10,5,9,6,6,10,3,9,5,5,5,6,7,9,8,5,3,3,9,23,5,7,9,9,9,4,3,8,9,9,10,6,2,4,8,8,8,5,5,5,2,9,6,6,6,5,8,9,7,7,7,4,10,1,7,7,7,9,10,1,7,4,10,3,7,4,10,10,8,7,4,5,1,1,7,6,6,6,8,8,9,9,9,7,4,6,8,7,7,2,9,8,3,4,4,2,10,6,4,4,5,7,10,10,2,2,5,5,5,6,9,8,8,8,1,10,10,10,5,5,8,8,8,23,10,10,10,3,3,8,6,9,9,9,1,10,6,6,6,8,8,8,10,2,1,3,23,5,5,6,6]},"shortStrips":{"1.1":[0]},"startStrips":{"1":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175]},"rtp":"0.990","name":"plate_990.xls","type":0,"randMode":"default"}}
--- END OF FILE: electron\rand-core\config\default.json ---

--- START OF FILE: electron\rand-core\config\define.json ---
{"line_count":25,"maxwin":10000,"paytable":{"1":{"id":1,"code":"H1","name":"å¥³äºº","times":[0,0,5,100,1000,5000]},"2":{"id":2,"code":"H2","name":"è‡­é¼¬","times":[0,0,4,50,300,1000]},"3":{"id":3,"code":"H3","name":"èœœèœ‚","times":[0,0,3,25,100,500]},"4":{"id":4,"code":"H4","name":"é¤ç›’","times":[0,0,0,25,100,500]},"5":{"id":5,"code":"L1","name":"A","times":[0,0,0,15,50,200]},"6":{"id":6,"code":"L2","name":"K","times":[0,0,0,15,50,200]},"7":{"id":7,"code":"L3","name":"Q","times":[0,0,0,10,25,150]},"8":{"id":8,"code":"L4","name":"J","times":[0,0,0,10,25,150]},"9":{"id":9,"code":"L5","name":10,"times":[0,0,0,5,20,100]},"10":{"id":10,"code":"L6","name":9,"times":[0,0,0,5,20,100]},"21":{"id":21,"code":"S","name":"Scatter","times":[0,0,0,0,0,0]},"22":{"id":22,"code":"W","name":"Wild","times":[0,0,0,0,0,0]},"23":{"id":23,"code":"GW","name":"GoldenWild","times":[0,0,0,0,0,0]}},"symbolCodes":{"H1":1,"H2":2,"H3":3,"H4":4,"L1":5,"L2":6,"L3":7,"L4":8,"L5":9,"L6":10,"S":21,"W":22,"GW":23},"symbolIDs":{"0":1,"1":2,"2":3,"3":4,"4":5,"5":6,"6":7,"7":8,"8":9,"9":10,"10":21,"11":22,"12":23},"randMode":[],"randModeCond":{},"maxWinChangeProb":0.8,"maxWinChangeLastN":3,"stripsMode":1,"window":{"width":5,"height":3,"count":15},"two_way":false,"two_way_free":false,"paylines":[[1,1,1,1,1],[0,0,0,0,0],[2,2,2,2,2],[0,1,2,1,0],[2,1,0,1,2],[0,0,1,0,0],[2,2,1,2,2],[1,0,0,0,1],[1,2,2,2,1],[1,0,1,0,1],[1,2,1,2,1],[0,1,0,1,0],[2,1,2,1,2],[1,1,0,1,1],[1,1,2,1,1],[0,1,1,1,0],[2,1,1,1,2],[0,1,2,2,2],[2,1,0,0,0],[0,2,0,2,0],[2,0,2,0,2],[1,0,2,0,1],[1,2,0,2,1],[0,0,1,2,2],[2,2,1,0,0]],"freeSpinAndRetriggerTimes":15,"mainRetryMax":500,"freeRetryMax":500,"freegame":{"payout":[0,1,5,20,100],"max":99999,"freeMultiplier":1},"buffer":{"y":[{"th":[5000],"strips":[0]},{"th":[3000,2900],"strips":[0,1]},{"th":[1500],"strips":[0]},{"th":[850],"strips":[0]}],"overMax":300000,"remainMax":300000,"remainMaxPercent":1}}
--- END OF FILE: electron\rand-core\config\define.json ---

--- START OF FILE: electron\rand-core\config\itemPrize.json ---
{"2":[{"score":"1","config":{"main":{"s1":[0],"s2":{"0":[0]},"reels":{"0":{"0":["1","1","1","1","1","L1"]}},"respin":{"0":{"0":[null,null,null,null,-2,1,null,null]},"20":{}}},"free":{"freeState":{"0":[0],"1":[0],"2":[0],"3":[0]},"multipleRangeMap":{"0":{"min":null,"minChance":null,"max":null,"maxChance":null},"1":{"min":null,"minChance":null,"max":null,"maxChance":null},"2":{"min":null,"minChance":null,"max":null,"maxChance":null},"3":{"min":null,"minChance":null,"max":null,"maxChance":null},"4":{"min":null,"minChance":null,"max":null,"maxChance":null}},"s1":[[0],[0],[0],[0],[0]],"respin":{"0":{"0":null},"20":{}},"s2":{"0":[0]},"reels":{"0":{"0":["1","1","1","1","1","L1"]}}},"plateMaxWin":3000,"plateMaxWinFlag":false,"ridMap":{"1":"1","1.1":"1"},"strips":{"1":[2,1,3,23,5,5,6,6,9,9,3,5,6,7,7,7,9,5,8,2,10,7,7,3,1,1,10,6,7,2,2,10,10,10,5,9,6,6,10,3,9,5,5,5,6,7,9,8,5,3,3,9,23,5,7,9,9,9,4,3,8,9,9,10,6,2,4,8,8,8,5,5,5,2,9,6,6,6,5,8,9,7,7,7,4,10,1,7,7,7,9,10,1,7,4,10,3,7,4,10,10,8,7,4,5,1,1,7,6,6,6,8,8,9,9,9,7,4,6,8,7,7,2,9,8,3,4,4,2,10,6,4,4,5,7,10,10,2,2,5,5,5,6,9,8,8,8,1,10,10,10,5,5,8,8,8,23,10,10,10,3,3,8,6,9,9,9,1,10,6,6,6,8,8,8,10,2,1,3,23,5,5,6,6]},"shortStrips":{"1.1":[2]},"startStrips":{"1":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175]},"name":"item_1","type":3,"id":"20"}}]}
--- END OF FILE: electron\rand-core\config\itemPrize.json ---

--- START OF FILE: electron\rand-core\config\items.json ---
{"2":{"type":2,"name":"BuyFree","rate":100,"count":10,"states":[{"min":1,"max":99999},{"min":2,"max":99999},{"min":3,"max":99999}],"stateSticks":{"high":[0],"low":[0]}}}
--- END OF FILE: electron\rand-core\config\items.json ---

--- START OF FILE: electron\rand-core\config\spec.json ---
{
  "name": "mtg-bonusBearGold",
  "mainPrizes": {
    "line": "/module/line.js"
  },
  "freePrizes": {
    "line": "/module/line.js"
  }
}
--- END OF FILE: electron\rand-core\config\spec.json ---

--- START OF FILE: electron\rand-core\core\rand.js ---
const { baseSpin, freeSpin } = require('../game/spin');
const { BaseReelsGenerator, FreeReelsGenerator } = require('../game/plate/reels-generator');
const path = require('path');
class Rand {

  /**
   * Creates an instance of Rand.
   * @param {any} gameConfigMap
   * @param {import('../../../rand-core-lib/')} randCoreLib
   * @memberof Rand
   */
  constructor(gameConfigMap, randCoreLib) {

    //--------------------è¨­å®šæª”å€å¡Š-------------------------//
    this.spec = require('../config/spec.json');
    /** @type {Map<string, any>} éŠæˆ²è¨­å®šæª” */
    this.gameConfigMap = gameConfigMap;
    /** @type {import('../../type/gameConfigType').Define} éŠæˆ²å®šç¾©æª” */
    this.define = this.gameConfigMap.get('define');
    /** @type {import('../../type/gameConfigType').High} Plate è¨­å®šæª”*/
    this.config = undefined
    /** @type {import('../../type/gameConfigType').High} é»˜èªPlateè¨­å®šæª” */
    this.currentDefault = undefined;
    this.randCoreControl = randCoreLib.rand_core_control;
    this.calculate = randCoreLib.calculate;
    this.randModeSet = new Set(this.define.randMode);

    //--------------------éŠæˆ²æœå‹™æ¨¡çµ„å€å¡Š-------------------------//
    this.gameSet = require('../game/util/gameSetting'); // éŠæˆ²è¨­å®š
    this.gameUtil = randCoreLib.utils; // å·¥å…·æ¨¡çµ„
    this.gameControl = new (require('../game/util/gameControl'))(this.define); // éŠæˆ²æ§åˆ¶æ¨¡çµ„
    this.baseReelsGenerator = new BaseReelsGenerator(this.gameUtil); // æŠ½ä¸»éŠæˆ²ç›¤é¢æ¨¡çµ„
    this.freeReelsGenerator = new FreeReelsGenerator(this.gameUtil);
    this.plateGenerator = new (require('../game/plate/plateGenerator'))(this.define, this.gameUtil); // æŠ½ç›¤é¢æœå‹™
    this.getPrizeService = new (require('../game/prize/getPrizeService'))(this.gameUtil); // ç®—åˆ†æœå‹™
    /** @type {import('../game/spin/baseSpin')} baseSpin */
    this.baseSpin = baseSpin.bind(this);
    /** @type {import('../game/spin/freeSpin')} freeSpin */
    this.freeSpin = freeSpin.bind(this);
    /** @type {import('../game/prize/prize')[]} ç®—åˆ†æ¨¡çµ„ä»‹é¢ */
    this.freePrizes = [];
    /** @type {import('../game/prize/prize')[]} ç®—åˆ†æ¨¡çµ„ä»‹é¢ */
    this.mainPrizes = [];
    this.init();
  }

  init() {
    for (const key in this.spec.mainPrizes) {
      const prizeModPath = this.spec.mainPrizes[key];
      const prizeClass = require(path.join(__dirname, '../game/prize', prizeModPath));
      const prizeInstance = new prizeClass(this.define, key, this.gameUtil);
      this.mainPrizes.push(prizeInstance);
    }
    for (const key in this.spec.freePrizes) {
      const prizeModPath = this.spec.freePrizes[key];
      const prizeClass = require(path.join(__dirname, '../game/prize', prizeModPath));
      const prizeInstance = new prizeClass(this.define, key, this.gameUtil);
      this.freePrizes.push(prizeInstance);
    }
  }

  updateConfigMap(gameConfigMap) {
    this.gameConfigMap = gameConfigMap;
  }

  /** @type {import('../../type/functionType').getSpinResult} */
  getSpinResult(betInfo, sysState, playerArgs) {

    const spinInfo = {
      targetType: this.gameSet.PRIZE_TYPE.NORMAL,
      isPVP: false,
      targetTotal: 0,
      targetMax: 0,
      targetMin: 0
    };

    this.randCoreControl.checkInfo(betInfo, sysState);
    this.randCoreControl.updateSpinInfo(betInfo, sysState, spinInfo, this.gameConfigMap, this.randModeSet, this.define);
    this.currentDefault = this.randCoreControl.chooseProbabilityTable(sysState, this.gameConfigMap, this.randModeSet);

    let spinResult = null;

    for (let reSpinCount = 0; reSpinCount < this.gameSet.RESPIN_MAX; reSpinCount++) {

      const canRespin = reSpinCount < this.gameSet.RESPIN_MAX * 0.9;
      // ç•¶é‡æŠ½æ¬¡æ•¸éå¤šæ™‚æ”¹ç‚ºè‡ªç„¶æ©Ÿç‡
      if (!canRespin) {
        spinInfo.targetType = this.gameSet.PRIZE_TYPE.NORMAL;
        spinInfo.isPVP = false;
        spinInfo.targetTotal = 0;
        spinInfo.targetMax = 0;
        spinInfo.targetMin = 0;
      }
      // æ›´æ–°æ©Ÿç‡è¡¨
      const config = this.randCoreControl.updateProbabilityTable(betInfo, sysState, spinInfo, this.randModeSet, this.gameConfigMap);
      if (config === undefined) {
        this.config = this.currentDefault;
      } else {
        this.config = config;
      }
      spinResult = this._getSpinResult(betInfo, sysState, spinInfo, playerArgs);
      if (spinResult !== null) {
        break;
      }
    }
    if (spinResult === null) {
      throw new Error('spinResult is null');
    }
    return spinResult;
  }

  /** @type {import('../../type/functionType')._getSpinResult} */
  _getSpinResult(betInfo, sysState, spinInfo, playerArgs) {
    
    // ä¸»éŠæˆ²
    const result = this.baseSpin(betInfo, sysState, spinInfo);
    if (result === null) {
      return null;
    };

    const spinResult = {
      game: result,
      isBuyFeature: spinInfo.targetType == this.gameSet.PRIZE_TYPE.BUY_FEATURE,
      isPrize: spinInfo.targetType == this.gameSet.PRIZE_TYPE.SPECIFIED,
      isPVP: spinInfo.isPVP,
    };

    return spinResult;
  }
}
module.exports = Rand;
--- END OF FILE: electron\rand-core\core\rand.js ---

--- START OF FILE: electron\rand-core\game\plate\feature\index.js ---
function deduplicatePoints(points) {
  const seen = new Map();
  const unique = [];

  for (const [x, y] of points) {
    const key = `${x},${y}`;
    if (!seen.has(key)) {
      seen.set(key, true);
      unique.push([x, y]);
    }
  }

  return unique;
}

function getRandomPositions(board, hitPoints, pickCounts) {
  // å»ºç«‹ hitPoints åº§æ¨™é›†åˆ
  const hitSet = new Set(hitPoints.map(point => point.join(',')));
  const results = [];

  // å…ˆæƒæç›¤é¢æ‰€æœ‰å¯é¸ä½ç½®ï¼ˆreel2~reel5ï¼Œx=1~4ï¼‰
  const candidates = [];
  for (let x = 1; x < board.length; x++) { // x=1~4
    for (let y = 0; y < board[x].length; y++) {
      // æ’é™¤board[0]ã€hitPointsã€symbol=21
      if (
        board[x][y] === 21 ||
        board[x][y] === 20 ||
        board[x][y] === 22 ||
        hitSet.has(`${x},${y}`) ||
        x === 0
      ) {
        continue;
      }
      candidates.push([x, y]);
    }
  }

  // éš¨æ©ŸæŠ½å–
  let pool = candidates.slice();
  for (let i = 0; i < pickCounts.length; i++) {
    const count = pickCounts[i];
    const picked = [];
    for (let j = 0; j < count && pool.length > 0; j++) {
      const idx = Math.floor(Math.random() * pool.length);
      picked.push(pool[idx]);
      pool.splice(idx, 1); // æŠ½éçš„å°±ç§»é™¤
    }
    results.push(...picked);
  }

  return deduplicatePoints(results);
}

module.exports = {
  getRandomPositions,
};

--- END OF FILE: electron\rand-core\game\plate\feature\index.js ---

--- START OF FILE: electron\rand-core\game\plate\plateGenerator.js ---
const GameSet = require('../util/gameSetting');
class PlateGenerator {

  /**
   * Creates an instance of PlateGenerator
   * @param {import('../../../type/gameConfigType').Define} define
   * @param {import('../../../../rand-core-lib/utils')} gameUtil 
   * @memberof PlateGenerator 
   */
  constructor(define, gameUtil) {

    this.gameUtil = gameUtil
    this.define = define;
    /** @type {import('../../../type/gameConfigType').High} */
    this.config = undefined;
    /** @type {import('./reels-generator/gameReels')} */
    this.plate = undefined;
  }

  use(config, plate) {

    this.config = config;
    this.plate = plate;
    this.plate.plateConfig = config;
  }

  /** @type {import('../../../type/functionType').randomPlate} */
  randomPlate(plateState, stateIndex) {

    // å–å¾—ç›¤é¢çš„å½©å¸¶
    const reelsName = this.plate.getReelsName(plateState, stateIndex);
    const plate = this._randomPlate(reelsName, plateState.goldenWildPosition);
    return plate;
  }

  genSingleReel(reelsName) {

    const reels = Array.from({ length: this.define.window.width }, () =>
      Array(this.define.window.height).fill(-1)
    );

    while (true) {
      for (let x = 0; x < this.define.window.width; x++) {
        let rids = reelsName[x];
        for (let y = 0; y < this.define.window.height; y++) {
          // å½©å¸¶ç·¨è™Ÿ
          let rid = rids[y];
          // å–å¾—é•·å½©å¸¶ç·¨è™Ÿ (çŸ­å½©å¸¶æŒ‡å‘é•·å½©å¸¶)
          let lrid = this.config.ridMap[rid];
          // å½©å¸¶
          let strip = this.config.strips[lrid];
          // çŸ­å½©å¸¶
          let shortStrip = this.config.shortStrips[rid];
          let stopIdx = -1;
          if (shortStrip != null) {
            stopIdx = shortStrip[this.gameUtil.getRandomInt(0, shortStrip.length)];
          }
          // é•·å½©å¸¶
          else {
            stopIdx = this.gameUtil.getRandomInt(0, strip.length);
          }
          let item = strip[stopIdx];
          reels[x][y] = item;
        }
      }
      let valid = true;
      for (let x = 0; x < reels.length; x++) {
        // ç¨ç«‹è¼ªä¸å¯å‡ºå–®è¼ªå‡ºç¾2é¡†scatter
        const scatterCount = reels[x].filter(item => item === GameSet.SCATTER).length;
        if (scatterCount > 1) {
          valid = false;
          break;
        }
      }
      if (valid) {
        break;
      }
    }

    return reels;
  }

  genWholeReel(reelsName) {

    const reels = Array.from({ length: this.define.window.width }, () =>
      Array(this.define.window.height).fill(-1)
    );

    let stopIdx = -1;
    for (let i = 0; i < this.define.window.width; i++) {
      // å½©å¸¶ç·¨è™Ÿ
      let lrid = reelsName[i];
      let rid = this.config.ridMap[lrid];
      // å½©å¸¶
      let strip = this.config.strips[rid];
      // çŸ­å½©å¸¶
      let shortStrip = this.config.shortStrips[lrid];
      if (shortStrip != null) {
        stopIdx = this.gameUtil.randomAry(shortStrip);
      }
      // é•·å½©å¸¶
      else {
        // æœ€å¾Œ8å€‹æ˜¯è§£ææ™‚éè£œçš„ ä¸æŠ½è©²ä½ç½®
        stopIdx = this.gameUtil.getRandomInt(0, strip.length - 8);
      }

      for (let ii = 0; ii < this.define.window.height; ii++) {
        // ç›¤é¢
        reels[i][ii] = strip[stopIdx + ii];
      }
    }

    return reels;
  }

  /** @type {import('../../../type/functionType')._randomPlate} */
  _randomPlate(reelNames, goldenWildPosition) {

    const stripsMode = this.define.stripsMode;
    let reels;

    if (stripsMode == 1) {
      reels = this.genWholeReel(reelNames);
    }
    else if (stripsMode == 0) {
      reels = this.genSingleReel(reelNames);
    }

    let featureLv = undefined;

    if (stripsMode == 1) {
      featureLv = reelNames[5] ?? 'L1';
    } else if (stripsMode == 0) {
      featureLv = reelNames[5]?.[0] ?? 'L1';
    }

    if (goldenWildPosition !== undefined) {
      for (const [x, y] of goldenWildPosition) {
        reels[x][y] = GameSet.M_WILD;
      }
    }

    const plate = {
      reels: reels,
    };

    return plate;
  }
}
module.exports = PlateGenerator
--- END OF FILE: electron\rand-core\game\plate\plateGenerator.js ---

--- START OF FILE: electron\rand-core\game\plate\reels-generator\baseReelsGenerator.js ---
const GameReels = require("./gameReels");
class BaseReelsGenerator extends GameReels {

  /**
   * Creates an instance of BaseReelsGenerator.
   * @param {import('../../../../../rand-core-lib/utils')} gameUtil
   * @memberof BaseReelsGenerator
   */
  constructor(gameUtil) {
    super(gameUtil);
  }

  /** @type {import('../../../../type/functionType').getReelsName} */
  getReelsName(plateState) {

    let sheet = this.config.main;
    let s1 = 0;
    let s2 = 0;
    // å–å¾—å½©å¸¶ç·¨è™Ÿ
    if (!plateState.flag) {
      s1 = this.gameUtil.randomAry(sheet.s1);
      s2 = this.gameUtil.randomAry(sheet.s2[s1]);
      plateState.s1 = s1;
      plateState.s2 = s2;
      plateState.flag = true;
      if (s1 === 19) {
        plateState.free = true;
      }
    }
    else {
      s1 = plateState.s1;
      s2 = plateState.s2;
    }
    // äº”è¼ªåˆ†åˆ¥å°æ‡‰çš„æ»¾è¼ªåç¨±
    const reelNames = sheet.reels[s1][s2];
    return reelNames;
  }
}
module.exports = BaseReelsGenerator
--- END OF FILE: electron\rand-core\game\plate\reels-generator\baseReelsGenerator.js ---

--- START OF FILE: electron\rand-core\game\plate\reels-generator\freeReelsGenerator.js ---
const GameReels = require("./gameReels");
class FreeReelsGenerator extends GameReels {

  /**
   * Creates an instance of FreeReelsGenerator.
   * @param {import('../../../../../rand-core-lib/utils')} gameUtil
   * @memberof FreeReelsGenerator
   */
  constructor(gameUtil) {
    super(gameUtil);
  }

  /** @type {import('../../../../type/functionType').getReelsName} */
  getReelsName(plateState, stateIndex) {

    let sheet = this.config.free;
    let s1 = 0;
    let s2 = 0;
    // å–å¾—å½©å¸¶ç·¨è™Ÿ
    if (!plateState.flag) {
      s1 = this.gameUtil.randomAry(sheet.s1[stateIndex]);
      s2 = this.gameUtil.randomAry(sheet.s2[s1]);
      plateState.s1 = s1;
      plateState.s2 = s2;
      plateState.flag = true;
    }
    else {
      s1 = plateState.s1;
      s2 = plateState.s2;
    }
    // äº”è¼ªåˆ†åˆ¥å°æ‡‰çš„æ»¾è¼ªåç¨±
    const reelNames = sheet.reels[s1][s2];

    return reelNames;
  }
}
module.exports = FreeReelsGenerator
--- END OF FILE: electron\rand-core\game\plate\reels-generator\freeReelsGenerator.js ---

--- START OF FILE: electron\rand-core\game\plate\reels-generator\gameReels.js ---
class GameReels {

  constructor(gameUtil) {
    /** @type {import('../../../../type/gameConfigType').Define} */
    this.define;
    /** @type {import('../../../../type/gameConfigType').High} */
    this.config;
    /** @type {import('../../../../../rand-core-lib/utils')} gameUtil */
    this.gameUtil = gameUtil;
  }

  /** @type {import('../../../../type/functionType').getReelsName} */
  getReelsName() {

    throw new Error('Method getReelsName() must be implemented');
  }

  /**
   * @param {import('../../../../type/gameConfigType').High} config
   */
  set plateConfig(config) {

    this.config = config;
  }
}
module.exports = GameReels
--- END OF FILE: electron\rand-core\game\plate\reels-generator\gameReels.js ---

--- START OF FILE: electron\rand-core\game\plate\reels-generator\index.js ---
const BaseReelsGenerator = require('./baseReelsGenerator');
const FreeReelsGenerator = require('./freeReelsGenerator');

module.exports = {
  BaseReelsGenerator: BaseReelsGenerator,
  FreeReelsGenerator: FreeReelsGenerator,
};
--- END OF FILE: electron\rand-core\game\plate\reels-generator\index.js ---

--- START OF FILE: electron\rand-core\game\prize\getPrizeService.js ---
class GetPrizeService {

  constructor(gameUtil) {
    /** @type {import('./module/prize')[]} */
    this.prizeInstances = [];
    /** @type {import('../util/gameUtil')} */
    this.gameUtil = gameUtil;
  }

  /**
   *
   *
   * @param {import('./module/prize')[]} prizeInstances
   * @memberof GetPrizeService
   */
  use(prizeInstances) {

    this.prizeInstances = prizeInstances;
  }

  get(plate) {

    const prizes = {
      win: [0, 0]
    };

    for (const prizeInstance of this.prizeInstances) {
      const prize = prizeInstance.get(plate);
      if (prize === null) {
        continue;
      }
      if (prize.win[0] !== 0 || prize.win[1] !== 0) {
        prizes[prizeInstance.key] = prize;
        prizes.win[0] += this.gameUtil.float(prize.win[0]);
        prizes.win[1] += this.gameUtil.float(prize.win[1]);
      }
    }

    return prizes;
  }
}
module.exports = GetPrizeService;
--- END OF FILE: electron\rand-core\game\prize\getPrizeService.js ---

--- START OF FILE: electron\rand-core\game\prize\module\line.js ---
const Prize = require('./prize');
const GameSet = require('../../util/gameSetting');
class Line extends Prize {

  /**
   * Creates an instance of Line.
   * @memberof Line
   */
  constructor(define, key, gameUtil) {
    super(define, key, gameUtil);
    this.height = this.define.window.height;
  }
  get(plate, isFree) {

    const globalMultiplier = isFree === true ? 3 : 1;
    const reels = plate.reels;

    // å…Œçç·šå®šç¾©
    const paylines = this.define.paylines;
    const result = {
      'win': [0, 0],
      'prizes': [],
    };

    // æª¢æŸ¥æ¯æ¢å…Œçç·š
    for (let lineIndex = 0; lineIndex < paylines.length; lineIndex++) {
      const line = paylines[lineIndex];
      const lineResult = this.checkLine(reels, line, lineIndex, globalMultiplier);

      if (lineResult.win > 0) {
        const { win, symbol, count, lineIdx } = lineResult;
        result.win[0] += lineResult.win;
        result.prizes.push([lineIdx, symbol, count, win, 0]);
      }
    }

    return result;
  }

  /**
   * æª¢æŸ¥å–®æ¢å…Œçç·š
   * @param {Array} reels - ç›¤é¢æ•¸æ“š 5x3
   * @param {Array} line - å…Œçç·šå®šç¾© [row, row, row, row, row]
   * @param {number} lineIndex - ç·šçš„ç´¢å¼•
   * @returns {Object} ä¸­ççµæœ
   */
  checkLine(reels, line, lineIndex, globalMultiplier) {
    const symbols = [];

    // æ ¹æ“šå…Œçç·šå–å¾—ç¬¦è™Ÿåºåˆ—
    for (let reel = 0; reel < 5; reel++) {
      const row = line[reel];
      const symbol = reels[reel][row];
      symbols.push(symbol);
    }

    // æª¢æŸ¥é€£çºŒç›¸åŒç¬¦è™Ÿï¼ˆå¾å·¦åˆ°å³ï¼‰
    let count = 1;
    let winSymbol = symbols[0];

    // æª¢æŸ¥æ˜¯å¦å…¨ç‚º WILD
    const allWild = symbols.every(symbol =>
      symbol === GameSet.WILD || symbol === GameSet.M
    );

    // å¦‚æœä¸æ˜¯å…¨ WILDï¼Œä¸”ç¬¬ä¸€å€‹ç¬¦è™Ÿæ˜¯ WILDï¼Œæ‰¾ä¸‹ä¸€å€‹é WILD ç¬¦è™Ÿä½œç‚ºä¸»è¦ç¬¦è™Ÿ
    if (!allWild && (winSymbol === GameSet.WILD || winSymbol === GameSet.M_WILD)) {
      for (let i = 1; i < symbols.length; i++) {
        if (symbols[i] !== GameSet.WILD && symbols[i] !== GameSet.M_WILD) {
          winSymbol = symbols[i];
          break;
        }
      }
    }

    for (let i = 1; i < symbols.length; i++) {
      if (this.equal(winSymbol, symbols[i])) {
        count++;
      } else {
        break;
      }
    }

    // æª¢æŸ¥æ˜¯å¦é”åˆ°æœ€å°ä¸­çæ•¸é‡
    let win = this.calculateWin(winSymbol, count);

    if (win > 0) {
      let mWildMultiplier = 1; // é€™æ˜¯é€™æ¢ç·š M_WILD è²¢ç»çš„å€ç‡

      // è¨ˆç®— M_WILD çš„å€ç‡ (1, 2, 4, 8...)
      for (let i = 0; i < count; i++) {
        if (symbols[i] === GameSet.M_WILD) {
          mWildMultiplier *= 2;
        }
      }

      let finalMultiplier = 0;

      if (mWildMultiplier === 1) {
        finalMultiplier = globalMultiplier;
      } else {
        finalMultiplier = mWildMultiplier + globalMultiplier;
      }

      win = win * finalMultiplier;

      return {
        win: win,
        symbol: winSymbol,
        count: count,
        lineIdx: lineIndex,
        multiplier: finalMultiplier
      };
    }

    return { win: 0 };
  }

  /**
   * è¨ˆç®—ä¸­çé‡‘é¡
   * @param {number} symbol - ä¸­çç¬¦è™Ÿ
   * @param {number} count - é€£çºŒæ•¸é‡
   * @returns {number} ä¸­çé‡‘é¡
   */
  calculateWin(symbol, count) {
    const paytable = this.define.paytable;
    const win = paytable[symbol]?.times?.[count] || 0;

    return win;
  }

  equal(symbolA, symbolB) {
    return symbolA === symbolB ||
      (symbolB === GameSet.WILD || symbolB === GameSet.M_WILD) ||
      (symbolA === GameSet.WILD || symbolA === GameSet.M_WILD);
  }
}

module.exports = Line
--- END OF FILE: electron\rand-core\game\prize\module\line.js ---

--- START OF FILE: electron\rand-core\game\prize\module\prize.js ---
class Prize {
  constructor(define, key, gameUtil) {
    /** @type {import('../../../../type/gameConfigType').Define} */
    this.define = define;
    /** @type {string} */
    this.key = key;
    /** @type {import('../../../../../rand-core-lib/utils')} */
    this.gameUtil = gameUtil;
  }
  get() {

    throw new Error('Method get() must be implemented');
    
  }
}
module.exports = Prize
--- END OF FILE: electron\rand-core\game\prize\module\prize.js ---

--- START OF FILE: electron\rand-core\game\spin\baseSpin.js ---
/**
 * @this {import('../../core/rand')}
 * @param {import('../../../type/randType').BetInfo} betInfo
 * @param {import('../../../type/randType').SystemState} sysState
 * @param {import('../../../type/randType').SpinInfo} spinInfo
 * @returns {import('../../../type/spinResultType').Game}
 */
module.exports = function (betInfo, sysState, spinInfo) {

  this.plateGenerator.use(this.config, this.baseReelsGenerator);
  this.getPrizeService.use(this.mainPrizes);

  const config = this.config;
  const gameSet = this.gameSet;
  const gameControl = this.gameControl;
  const define = this.define;
  const plateGenerator = this.plateGenerator;
  const prizeService = this.getPrizeService;

  const result = {
    totalWin: [0, 0],
    mainWin: [0, 0],
  };
  let totalWin = 0;
  const plateState = {
    flag: false,
    free: false,
  };
  // ä¸»éŠæˆ²é–‹å§‹
  let mainRetry = 0;
  const respinProb = Math.random();

  do {
    let maxWin = false;
    mainRetry++;
    // ä¸»éŠæˆ²ç›¤é¢
    const plate = plateGenerator.randomPlate(plateState);
    const prizes = prizeService.get(plate);
    const mainWin = gameControl.getTotalWin(prizes.win);
    const canEntryFreeSpin = gameControl.checkEntryFreeSpin(plate.reels);
    if (mainWin >= define.maxwin) {
      maxWin = true;
      prizes.maxWin = true;
      prizes.win[0] = define.maxwin * define.line_count;
    }

    result.plate = plate;
    result.prizes = prizes;

    if (plateState.free === true && !canEntryFreeSpin) {
      continue;
    }

    if (mainRetry < define.mainRetryMax) {

      let respinCondition = null;

      if (respinCondition === null && config.main.respin && plateState.s1 !== undefined && plateState.s2 !== undefined) {

        respinCondition = config.main.respin[plateState.s1][plateState.s2]
      }
      if (gameControl.checkRedraw(respinCondition, respinProb, mainWin, prizes)) {
        continue;
      }
    }
    // å®Œæˆä¸»éŠæˆ²ï¼Œé›¢é–‹è¿´åœˆ
    break;
  } while (mainRetry < define.mainRetryMax)

  const { canEntry, goldenCount, normalCount } = gameControl.checkEntryFreeSpin(result.plate.reels);

  if (canEntry === true) {
    const freeError = this.freeSpin(result, goldenCount, normalCount);
    if (freeError === true) return null;
  }
  result.mainWin = result.prizes.win;

  result.totalWin[0] += result.mainWin[0];
  result.totalWin[1] += result.mainWin[1];

  if (result.free) {
    result.totalWin[0] += result.free.win[0];
    result.totalWin[1] += result.free.win[1];
  }

  totalWin = gameControl.getTotalWin(result.totalWin);

  // æª¢æŸ¥å–®ç­†è´åˆ†æ˜¯å¦è¶…éPlateè¨­å®šçš„ä¸Šé™
  if (this.config.plateMaxWinFlag === true && this.config.plateMaxWin > 0 && totalWin > this.config.plateMaxWin) {
    // å¦‚æœè¶…éä¸Šé™ï¼Œè¿”å› null
    return null;
  }

  if (spinInfo.targetType == gameSet.PRIZE_TYPE.NORMAL) {
    // æª¢æŸ¥å–®ç­†è´åˆ†æ˜¯å¦è¶…éç³»çµ±è¨­å®šçš„é™ç´…
    if (sysState.targetWinLimit != undefined && sysState.targetWinLimit > 0 && totalWin > sysState.targetWinLimit) {
      // å¦‚æœè¶…éé™ç´…ï¼Œå‰‡è¿”å› null
      return null;
    }
  }
  else {
    // å¦‚æœçé …é¡å‹æ˜¯è³¼è²·ç‰¹è‰²éŠæˆ²
    if (spinInfo.targetType == gameSet.PRIZE_TYPE.BUY_FEATURE) {
      if (!gameControl.isValidBuyFeature(betInfo.buyFeatureType, result)) {
        // æª¢æŸ¥è³¼è²·ç‰¹è‰²éŠæˆ²çš„åˆæ³•æ€§ï¼Œå¦‚æœä¸åˆæ³•ï¼Œè¿”å› null
        return null;
      }
    }
    if (totalWin < spinInfo.targetMin || totalWin > spinInfo.targetMax) {
      return null;
    }
  }
  return result;
}
--- END OF FILE: electron\rand-core\game\spin\baseSpin.js ---

--- START OF FILE: electron\rand-core\game\spin\freeSpin.js ---
/**
 * @this {import('../../core/rand')}
 * @param {import('../../../type/spinResultType').Game} gameResult 
 * @returns {boolean}
 */
module.exports = function (gameResult, goldenCount, normalCount) {

  let stateIndex = 0;
  if (goldenCount === 3 && normalCount === 0) {
    stateIndex = 3;
  }
  else if (goldenCount === 2 && normalCount === 1) {
    stateIndex = 2;
  }
  else if (goldenCount === 1 && normalCount === 2) {
    stateIndex = 1
  }
  else if (goldenCount === 0 && normalCount === 3) {
    stateIndex = 0;
  }
  let goldenWildPosition = [];

  if (goldenCount > 0) {
    const reels = gameResult.plate.reels;
    for (let x = 0; x < reels.length; x++) {
      for (let y = 0; y < reels[x].length; y++) {
        if (reels[x][y] === this.gameSet.M_WILD) {
          goldenWildPosition.push([x, y]);
        }
      }
    }
  }
  const F_RETRY_MAX = 100;
  const mainWin = this.gameControl.getTotalWin(gameResult.totalWin);
  let freeCount = this.define.freeSpinAndRetriggerTimes;

  this.plateGenerator.use(this.config, this.freeReelsGenerator);
  this.getPrizeService.use(this.freePrizes);
  let maxWin;
  const reSpinCondition = this.config.free.freeState[stateIndex];
  const multipleMap = this.config.free.multipleRangeMap;
  const rangeIndex = this.gameUtil.randomAry(reSpinCondition);

  const { min, minChance, max, maxChance } = multipleMap[rangeIndex];
  const minProb = Math.random();
  const maxProb = Math.random();

  let fTotalWin = 0;
  let totalRetry = 0;
  let fRetry = 0;
  let freePlus = [freeCount];

  let result = {
    win: [0, 0],
    times: freeCount,
    results: [],
  };

  // æ¯å±€
  runLoop: do {
    let reTry = 0;
    maxWin = false;
    let fCount = freePlus.shift();
    let fResults = [];
    let fPlusCount = 0;
    let plateState = {
      flag: false,
      goldenWildPosition: goldenWildPosition,
    };

    // æ¯æ¬¡
    while (fCount > 0) {
      reTry++;
      maxWin = false;
      const respinProb = Math.random();
      let fTotalCount = fResults.length + result.results.length + fCount;
      fTotalCount += freePlus.length * freeCount;
      let fResult = {
        win: [0, 0],
        plate: {},
        prizes: {},
      };

      const plate = this.plateGenerator.randomPlate(plateState, rangeIndex);
      const prizes = this.getPrizeService.get(plate);

      const downWin = this.gameControl.getTotalWin(prizes.win);

      if (downWin + mainWin + fTotalWin >= this.define.maxwin) {
        prizes.win[0] = (this.define.maxwin - mainWin - fTotalWin) * this.define.line_count;
        prizes.maxWin = true;
        maxWin = true;
      }

      if (reTry < this.define.freeRetryMax) {

        let respinCondition = null;

        if (respinCondition === null && this.config.free.respin && plateState.s1 !== undefined && plateState.s2 !== undefined) {

          respinCondition = this.config.free.respin[plateState.s1][plateState.s2]
        }
        if (this.gameControl.checkRedraw(respinCondition, respinProb, mainWin, prizes)) {
          continue;
        }
      }

      // è¨ˆç®—ç‰¹æ®Šç‰©ä»¶ (scatter)
      let canRetrigger = this.gameControl.checkEntryFreeSpin(plate.reels);

      fResult.plate = plate;
      fResult.prizes = prizes;

      fPlusCount = canRetrigger ? this.define.freegame.retriggerTimes : 0;

      // fPlusCount = 0
      if (fPlusCount > 0) {
        if (fRetry < F_RETRY_MAX) {
          // å…è²»éŠæˆ²æ¬¡æ•¸è¶…éä¸Šé™æ™‚é‡æŠ½
          if (fTotalCount >= this.define.freegame.max) {
            fRetry++;
            continue;
          }
        }
        fResult.free = fPlusCount;
        freePlus.push(fPlusCount);
      }

      fResults.push(fResult);

      plateState = {
        flag: false,
      }

      // è¨ˆç®—ç•¶å‰spinçš„è´åˆ†
      const thisFreeSpinWin = this.gameControl.getTotalWin(prizes.win);
      fTotalWin += thisFreeSpinWin;
      if (maxWin) {
        fCount = 0;
        freePlus.length = 0;
      }
      fCount--;
    }
    result.results = result.results.concat(fResults);

    if (freePlus.length == 0 && totalRetry < 500) {
      const canRespin = totalRetry < 500 * 0.9;
      if (!canRespin) {
        return true;
      }
      let retry = false;
      // ç¸½è´åˆ†å¹¾å€ä»¥ä¸Šã€å¹¾å€ä»¥ä¸‹é‡æŠ½
      if ((fTotalWin > max && maxChance > maxProb) || (fTotalWin < min && minChance > minProb)) {
        retry = true;
      }
      if (retry === true) {
        totalRetry++;
        fTotalWin = 0;
        result.results = [];
        result.win[0] = 0;
        result.win[1] = 0;
        freePlus = [freeCount];
        continue runLoop;
      }
    }
  } while (freePlus.length > 0);
  gameResult.free = result;
  return false;
};
--- END OF FILE: electron\rand-core\game\spin\freeSpin.js ---

--- START OF FILE: electron\rand-core\game\spin\index.js ---
const baseSpin = require('./baseSpin');
const freeSpin = require('./freeSpin');

module.exports = {
  baseSpin,
  freeSpin,
}
--- END OF FILE: electron\rand-core\game\spin\index.js ---

--- START OF FILE: electron\rand-core\game\util\gameControl.js ---
const gameSet = require('./gameSetting');
const gameUtil = require('./gameUtil');
class GameControl {

  constructor(define) {
    this.define = define;
  }

  isValidBuyFeature(buyFeatureType, result) {

    if (buyFeatureType == gameSet.PRIZE_TYPE.PVP) {
      if (typeof result.free !== 'undefined' && result.free.results.length === 10) {
        return true;
      } else {
        return false;
      }
    }
    return result.free !== undefined && buyFeatureType == gameSet.PRIZE_TYPE.BUY_FEATURE;
  };

  checkRedraw(respinCondition, respinProb, mainWin, prizes) {

    if (respinCondition !== null) {
      // å¹¾å€ä»¥ä¸Šé‡æŠ½
      const max = respinCondition[0];
      const maxProb = respinCondition[1];
      if (maxProb != null && respinProb < maxProb && mainWin > max) {
        return true;
      }
      // å¹¾å€ä»¥ä¸‹é‡æŠ½
      const min = respinCondition[2];
      const minProb = respinCondition[3];
      if (minProb != null && respinProb < minProb && mainWin < min) {
        return true;
      }
      // å¹¾ç·šé‡æŠ½
      const lineCount = respinCondition[4];
      const lineCountProb = respinCondition[5];
      // å¹¾é€£é‡æŠ½
      const length = respinCondition[6];
      const lengthProb = respinCondition[7];

      if (prizes.line) {
        const linePrizes = prizes.line.prizes;
        if (lineCountProb != null && respinProb < lineCountProb) {
          // æ­£æ•¸è¡¨ç¤ºæœ€å¤šå¹¾ç·šï¼Œè² æ•¸è¡¨ç¤ºè‡³å°‘å¹¾ç·š
          if (lineCount > 0) {
            if (linePrizes.length > lineCount) {
              return true;
            }
          }
          else if (lineCount < 0) {
            if (linePrizes.length < Math.abs(lineCount)) {
              return true;
            }
          }
        }
        if (lengthProb != null && respinProb < lengthProb) {
          let maxLength = 0;
          for (const prize of linePrizes) {
            if (prize[2] > maxLength) {
              maxLength = prize[2];
            }
          }
          // æ­£æ•¸è¡¨ç¤ºæœ€å¤šå¹¾é€£ï¼Œè² æ•¸è¡¨ç¤ºè‡³å°‘å¹¾é€£
          if (length > 0) {
            if (maxLength > length) {
              return true;
            }
          }
          else if (length < 0) {
            if (maxLength < Math.abs(length)) {
              return true;
            }
          }
        }
      }
    }

    return false;
  }

  getTotalWin(win) {

    return gameUtil.float((win[0] / this.define.line_count) + win[1]);
  }

  countTargetSymbolCount(reels, targetSymbol) {

    let symbolCount = 0;
    for (const reel of reels) {
      symbolCount += reel.filter(symbol => symbol === targetSymbol).length;
    }

    return symbolCount;
  }


  /**
   * æª¢æŸ¥2,3,4è¼ªæ˜¯å¦éƒ½æœ‰WILD
   *
   * @param {number[][]} reels
   * @return {{canEntry: boolean, goldenCount: number, normalCount: number}} 
   * @memberof GameControl
   */
  checkEntryFreeSpin(reels) {

    let golden = 0;
    let normal = 0;
    const r2 = reels[1];
    const r3 = reels[2];
    const r4 = reels[3];

    golden += r2.filter(item => item === gameSet.WILD_GOLDEN).length;
    golden += r3.filter(item => item === gameSet.WILD_GOLDEN).length;
    golden += r4.filter(item => item === gameSet.WILD_GOLDEN).length;

    normal += r2.filter(item => item === gameSet.WILD).length;
    normal += r3.filter(item => item === gameSet.WILD).length;
    normal += r4.filter(item => item === gameSet.WILD).length;

    if (normal + golden >= 3) {
      return { canEntry: true, goldenCount: golden, normalCount: normal };
    }

    return { canEntry: false, goldenCount: golden, normalCount: normal };
  }
}
module.exports = GameControl
--- END OF FILE: electron\rand-core\game\util\gameControl.js ---

--- START OF FILE: electron\rand-core\game\util\gameSetting.js ---
module.exports = {
  CONFIG_TYPE: {
    DEFAULT: 0,
    SPECIFIED: 2,
    BUY_FEATURE: 3
  },
  PRIZE_TYPE: {
    NORMAL: 0,
    SPECIFIED: 1,
    BUY_FEATURE: 2,
    PVP: 9,
  },
  RESPIN_MAX: 1000,
  WILD: 22,
  M_WILD: 23,
  SCATTER: 21,
};
--- END OF FILE: electron\rand-core\game\util\gameSetting.js ---

--- START OF FILE: electron\rand-core\game\util\gameUtil.js ---
class GameUtil {

  constructor() { }

  static isNil(val) {
    return val === null || val === undefined || val === '' || val == 0;
  }

  static deepClone(object) {
    if (object === null || typeof object !== 'object') {
      return object;
    }

    if (Array.isArray(object)) {
      const cloned = new Array(object.length);
      for (let i = 0; i < object.length; i++) {
        cloned[i] = this.deepClone(object[i]);
      }
      return cloned;
    }

    const cloned = {};
    for (const key in object) {
      if (object.hasOwnProperty(key)) {
        cloned[key] = this.deepClone(object[key]);
      }
    }

    return cloned;
  }

  static randomStr(str) {
    return str[Math.floor(Math.random() * str.length)];
  };
  static randomAry(ary) {
    return ary[Math.floor(Math.random() * ary.length)];
  };

  static getRandomInt(min, max) {
    return Math.floor(Math.random() * (max - min)) + min;
  };

  static float(val) {
    return Math.round(val * 100) / 100;
  };

  static shuffle(array) {
    let m = array.length, t, i;
    // While there remain elements to shuffleâ€¦
    while (m) {
      // Pick a remaining elementâ€¦
      i = Math.floor(Math.random() * m--);

      // And swap it with the current element.
      t = array[m];
      array[m] = array[i];
      array[i] = t;
    }
    return array;
  };

  static shuffleLen(array, len) {
    let m = len, t, i;
    // While there remain elements to shuffleâ€¦
    while (m) {
      // Pick a remaining elementâ€¦
      i = Math.floor(Math.random() * m--);

      // And swap it with the current element.
      t = array[m];
      array[m] = array[i];
      array[i] = t;
    }
    return array;
  };

  static shuffleOne(array, index) {
    let t, i;
    i = Math.floor(Math.random() * array.length);
    // And swap it with the current element.
    t = array[index];
    array[index] = array[i];
    array[i] = t;
  };

  static swap(array, i, ii) {
    let tmp = array[i];
    array[i] = array[ii];
    array[ii] = tmp;
  };
}
module.exports = GameUtil;
--- END OF FILE: electron\rand-core\game\util\gameUtil.js ---

--- START OF FILE: electron\rand-core\index.js ---
const path = require('path');
const fs = require('fs');

// ç†±æ›´æ–°æª¢æŸ¥é–“éš” (s)
const RELOAD_INTERVAL = 30;

const getTimestamp = function () {
  let dateTime = Date.now();
  let timestamp = Math.floor(dateTime / 1000);
  return timestamp;
};

/**
 * RandTheme Constractor
 */
class RandTheme {
  constructor(randCoreLib) {
    this.hash = '';
    this.logPrefix = "[RAND]";

    // ç†±æ›´æ–°åƒæ•¸
    this.waitReload = false;
    this.hashChecking = false;
    this.reloadEnable = true;

    // æ©Ÿç‡
    this.randPath = path.resolve(__dirname, 'core', 'rand.js');
    this.gameConfigRootPath = path.resolve(__dirname, 'config');
    this.gameHashPath = path.resolve(this.gameConfigRootPath, 'hash.txt');
    this.gameSpecPath = path.resolve(this.gameConfigRootPath, 'spec.json');

    this.allSettingPath = this.getAllJsonPaths(this.gameConfigRootPath);
    this.configMap = new Map();

    try {
      const gameHash = fs.readFileSync(this.gameHashPath, 'utf8');
      this.hash = gameHash;
      this.lastCheckReload = getTimestamp();
    }
    catch (err) {
      console.error(err);
      this.reloadEnable = false;
    }
    this.newRand(randCoreLib);
  }

  getAllJsonPaths(dir, { absolute = true, includeSymlinks = false } = {}) {

    const names = fs.readdirSync(dir, { withFileTypes: true });
    const list = names
      .filter(e => e.isFile() || (includeSymlinks && e.isSymbolicLink()))
      .filter(e => path.extname(e.name).toLowerCase() === '.json')
      .map(e => absolute ? path.join(dir, e.name) : e.name);

    return list;
  }

  initConfigMap() {

    this.configMap.clear();
    for (const _path of this.allSettingPath) {
      const context = fs.readFileSync(_path, 'utf-8');
      const configName = _path.split(path.sep).pop().split('.')[0];
      if (!['default', 'define', 'items', 'free-round-items'].includes(configName)) {
        continue;
      }
      this.configMap.set(configName, JSON.parse(context));
    }
  }

  newRand(randCoreLib) {
    try {
      // æ©Ÿç‡æ¨¡çµ„
      delete require.cache[require.resolve(this.randPath)];
      const Rand = require(this.randPath);
      this.spec = require(this.gameSpecPath);
      this.initConfigMap();
      if (!randCoreLib) {
        randCoreLib = require('../../rand-core-lib');
      }
      // ç”Ÿæˆæ–°çš„æ©Ÿç‡æ¨¡çµ„
      /** @type {import('./core/rand')} */
      this.rand = new Rand(this.configMap, randCoreLib);
      const buyFeatureInfos = {};

      if (this.configMap.has('items') && Object.keys(this.configMap.get('items')).length > 0) {
        const itemsConfig = this.configMap.get('items');
        Object.keys(itemsConfig).forEach(function (key) {
          let value = itemsConfig[key];
          buyFeatureInfos[value.type] = {
            name: value.name,
            type: value.type,
            rate: value.rate,
            total: value.count,
          };
        });
      }
      this.gameInfo = {
        lineCount: this.configMap.get('define').line_count,
        buyFeatureInfos: buyFeatureInfos,
        randMode: this.spec.randMode,
      };
    }
    catch (e) {
      console.error(e);
      throw e;
    }
  }
  /**
   * å–å¾—éŠæˆ²è³‡æ–™
   *
   */
  getInfo() {
    return this.gameInfo;
  }

  /**
   * å–å¾—æ©Ÿå°ç‹€æ…‹
   * @param  {Number[]}    æŠ¼åˆ†
   * @return {Object}    æ©Ÿå°ç‹€æ…‹
   */
  createState(bets) {
    return {};
  }

  /**
   * å–å¾—Spinçµæœ
   * @param {import('../type/randSystem').BetInfo} betInfo
   * @param {import('../type/randSystem').SysState} sysState
   * @param {Object} macBuffer 
   * @param {{playerState:any,playerAction:{Index:number}}} playerArgs
   * @returns
   */
  getSpinResult(betInfo, sysState, macBuffer, playerArgs) {
    try {
      // ç†±æ›´æ–°
      if (this.waitReload == true) {
        this.newRand();
        this.waitReload = false;
        console.log('update success HASH:' + this.hash);
      }
      // æª¢æŸ¥ç†±æ›´æ–°
      if (this.reloadEnable == true) {
        const now = getTimestamp();
        const deltaTime = now - this.lastCheckReload;
        if (deltaTime > RELOAD_INTERVAL && this.hashChecking == false) {
          this.hashChecking = true;
          const self = this;
          fs.readFile(this.gameHashPath, 'utf8', function (error, newHash) {
            if (error == null) {
              if (self.hash != newHash) {
                // ç­‰å¾…ç†±æ›´æ–°
                console.log('update waiting... HASH:' + newHash);
                self.hash = newHash;
                self.waitReload = true;
              }
            }
            self.hashChecking = false;
            self.lastCheckReload = getTimestamp();
          });
        }
      };

      if (betInfo.buyFeatureType !== undefined && !this.configMap.has('itemPrize')) {
        this.setAndUpdateMap('itemPrize', 'itemPrize');
      }

      if (betInfo.buyFeatureType !== undefined && !this.configMap.has('free-round-itemPrize') && sysState.randMode === 'free-round') {
        this.setAndUpdateMap('free-round-itemPrize', 'free-round-itemPrize');
      }

      if (sysState.targetPrizeType !== undefined && !this.configMap.has('mainPrize')) {
        this.setAndUpdateMap('mainPrize', 'mainPrize');
      }

      if (sysState.randMode !== undefined && !this.configMap.has(sysState.randMode)) {
        this.setAndUpdateMap(sysState.randMode, sysState.randMode);
      }

      const spinResult = this.rand.getSpinResult(betInfo, sysState, playerArgs);
      // console.log(JSON.stringify(spinResult));
      
      return spinResult;
    }
    catch (error) {
      console.error(error);
      throw error;
    }
  }

  setAndUpdateMap(keyName, fileName) {
    const setting = this.getConfig(fileName);
    this.configMap.set(keyName, setting);
    this.rand.updateConfigMap(this.configMap);
  }

  getConfig(fileName) {

    const wholePath = `${this.gameConfigRootPath}/${fileName}.json`;

    if (fs.existsSync(wholePath) === false) {
      console.warn('Config file not found: ' + wholePath);
      return {};
    }
    const context = fs.readFileSync(wholePath, 'utf-8');
    return JSON.parse(context);
  }

  /**
   * åˆªé™¤ç©å®¶ç‹€æ…‹
   *
   * @param {Object} playerState
   * @memberof RandTheme
   */
  deletePlayerState(playerState) {

    if (playerState && playerState.gameStatus) {
      delete playerState.gameStatus;
    }
  }
}

module.exports = function (randCoreLib) {
  try {
    return new RandTheme(randCoreLib);
  }
  catch (e) {
    console.error(e);
    return null;
  }
};

--- END OF FILE: electron\rand-core\index.js ---

--- START OF FILE: electron\rand-core\package.json ---
{
  "type": "commonjs"
}
--- END OF FILE: electron\rand-core\package.json ---

--- START OF FILE: electron\rand-core\parser\game\parser-define.js ---
const Parser = require("./parser");
const payLines = require('./paylines.json');
class Define extends Parser {

  constructor() {
    super();
  }

  /**
   *
   *
   * @param {Object} sheets
   * @return {Object} 
   * @memberof Define
   */
  parser(sheets) {

    const config = {};

    // æŠ¼æ³¨ç·šæ•¸
    config.line_count = parseInt(sheets.Define["V2"]);
    // maxwin
    config.maxwin = parseInt(sheets.Define["V5"]);
    // çåœ–å€æ•¸ 11å€‹ Sheet[AB~AI, 3~14]
    config.paytable = {};
    // ä»£è™Ÿè½‰ç·¨è™Ÿ (å½©å¸¶ç”¨)
    config.symbolCodes = {};
    // æµæ°´è™Ÿè½‰ç·¨è™Ÿ (ç±¤æ¡¶ç”¨)
    config.symbolIDs = {};
    config.randMode = [];
    config.randModeCond = {};
    for (let i = 0; i < 50; i++) {
      let val = sheets.RandMode["D" + (7 + i)];
      if (!val) break;
      config.randMode.push(val.toLowerCase());
    }

    for (let i = 0; i < 10; i++) {
      const key = sheets.RandMode["F" + (i + 7)];
      if (!key) break;
      config.randModeCond[key] = {
        maxBetCount: sheets.RandMode["E" + (i + 7)],
        fallBackMode: sheets.RandMode["G" + (i + 7)] === 'default' ? undefined : sheets.RandMode["G" + (i + 7)],
      };
    }

    config.maxWinChangeProb = sheets.Define['P12'];
    config.maxWinChangeLastN = sheets.Define['P13'];
    config.stripsMode = sheets.Define['AA7'];
    for (let i = 0; i < 20; i++) {
      let symbol = {};
      symbol.id = sheets.Define["A" + (i + 3)];
      if (symbol.id == null)
        continue;
      symbol.code = sheets.Define["B" + (i + 3)];
      symbol.name = sheets.Define["C" + (i + 3)];
      symbol.times = [0];
      for (let ii = 1; ii < 6; ii++) {
        let val = sheets.Define[this.util.idx2AZ(2 + ii) + (i + 3)];
        symbol.times[ii] = val ? val : 0;
      }
      config.paytable[symbol.id] = symbol;
      config.symbolCodes[symbol.code] = symbol.id;
      config.symbolIDs[i] = symbol.id;
    }

    // è¦–çª—å¤§å°, 5x3 or 5x4
    config.window = {};
    config.window.width = 5;
    config.window.height = sheets.Define["AA3"];
    config.window.count = config.window.width * config.window.height;

    // æ´¾å½©ç·šæ•¸
    config.two_way = sheets.Define["AA5"] == 1;
    config.two_way_free = sheets.Define["AA6"] == 1;
    let payline_count = sheets.Define["AA4"];

    // æ´¾å½©ç·šè¡¨, ç•¶æ´¾å½©ç·šæ•¸ç·š=Xæ™‚ä»£è¡¨è·¯è·¯é€š
    if (payline_count != 'X') {
      config.paylines = payLines.paylines;
    }
    config.freeSpinAndRetriggerTimes = sheets.Define["P9"];

    // ä¸»éŠæˆ²é‡æŠ½æ¬¡æ•¸ä¸Šé™
    config.mainRetryMax = sheets.Define["S7"];
    config.freeRetryMax = sheets.Define["S10"];
    // freeGame
    config.freegame = {
      payout: [0],
      max: 0,
      freeMultiplier: 0,
    };
    for (let i = 3; i < 50; i++) {
      const payout = sheets.Define["P" + i];
      if (payout === undefined || payout === null || payout === '') {
        break;
      }
      config.freegame.payout.push(payout);
    }

    if (sheets.Define["T2"]) {
      config.freegame.max = sheets.Define["T2"];
    }

    if (sheets.Define['T3']) {
      config.freegame.freeMultiplier = sheets.Define['T3'];
    }

    // Yæ°´æ± é–€æª»
    var buffer = {
      y: []
    };
    // Y1 ~ Y4
    for (var i = 0; i < 4; i++) {
      buffer.y[i] = {
        th: [],
        strips: []
      };

      var x1 = this.util.idx2AZ(i * 5 + 1);
      var x2 = this.util.idx2AZ(i * 5 + 2);

      for (var ii = 0; ii < 10; ii++) {
        var y = ii + 5;
        var threshold = sheets.Buffer[x1 + y];
        var stickCount = sheets.Buffer[x2 + y];
        if (threshold && stickCount) {
          this.util.appendAry(buffer.y[i].strips, buffer.y[i].th.length, stickCount);
          buffer.y[i].th.push(Number(threshold));
        }
      }
      this.util.resizeSticksAry(buffer.y[i].strips);
    }
    // ä¸Šä¸‹é™
    buffer.overMax = sheets.Buffer["AA4"] ? Number(sheets.Buffer["AA4"]) : 0;
    buffer.remainMax = sheets.Buffer["AA5"] ? Number(sheets.Buffer["AA5"]) : 0;
    buffer.remainMaxPercent = sheets.Buffer["AA6"] ? Number(sheets.Buffer["AA6"]) : 0;
    config.buffer = buffer;

    this.parseFeature(config, sheets);

    return config;
  }

  /**
   *
   *
   * @param {Object} config
   * @param {Object} sheets
   * @memberof Define
   */
  parseFeature(config, sheets) { }
}
module.exports = Define
--- END OF FILE: electron\rand-core\parser\game\parser-define.js ---

--- START OF FILE: electron\rand-core\parser\game\parser-plate.js ---
const Parser = require("./parser");

class Plate extends Parser {

  constructor(tableLoader) {
    super();
    this.tableLoader = tableLoader;
  }

  /**
   *
   *
   * @param {Object} config
   * @param {Object} sheets
   * @return {Object} 
   * @memberof Plate
   */
  parser(config, sheets) {

    const result = {};
    result.main = this.parseMainPlate(sheets, config);
    result.feature = this.parseFeature(sheets);
    result.free = this.parseFreePlate(sheets, config);
    this.parsePlateMaxWin(sheets, result);
    // å½©å¸¶ [rid]
    var strips = {};
    // çŸ­å½©å¸¶
    var shortStrips = {};

    // å½©å¸¶èµ·å§‹ä½ç½®ç±¤ [rid]
    var startStrips = {};

    // å½©å¸¶ç´¢å¼•æŸ¥å½©å¸¶ID
    var ridMap = {};
    result.ridMap = ridMap;

    // 20æ¢ä¸»å½©å¸¶
    [sheets.Reel, sheets.Reel2].forEach(sheet => {
      for (var i = 0; i < 10; i++) {
        var rid = sheet[this.util.idx2AZ(i * 15) + 2];
        var x = this.util.idx2AZ(i * 15 + 2);
        // èµ·å§‹ä½ç½®
        var x2 = this.util.idx2AZ(i * 15 + 1);
        var reel = [];

        // é–‹å§‹ä½ç½®ç±¤æ•¸
        var startStrip = [];
        for (var ii = 0; ii < 4096; ii++) {
          var key = x + (ii + 3);
          var code = sheet[key];
          // ç•¶çåœ–ç·¨è™Ÿæœªå¡«æ­¤æ¢å½©å¸¶çµæŸ
          if (code == null) {
            break;
          }
          // å°‡çåœ–ä»£è™Ÿè½‰æ›æˆID
          if (config.symbolCodes[code] === null || config.symbolCodes[code] === undefined) {
            throw new Error('çåœ–ä»£è™Ÿè½‰æ›éŒ¯èª¤');
          }

          reel.push(config.symbolCodes[code]);

          // è©²ä½ç½®ç±¤æ•¸
          var stickCount = sheet[x2 + (ii + 3)];
          if (stickCount && stickCount > 0) {
            startStrip = this.util.appendAry(startStrip, ii, stickCount);
          }
        }
        startStrip = this.util.resizeSticksAry(startStrip);

        if (reel.length == 0)
          continue;

        var reelLen = reel.length;

        // å°‡å½©å¸¶å¾ªç’°å¤šå¡«8ä½ æ–¹ä¾¿é‹ç®—
        reel.push(reel[0]);
        reel.push(reel[1]);
        reel.push(reel[2]);
        reel.push(reel[3]);
        reel.push(reel[4]);
        reel.push(reel[5]);
        reel.push(reel[6]);
        reel.push(reel[7]);

        strips[rid] = reel;
        startStrips[rid] = startStrip;
        ridMap[rid] = rid;

        // çŸ­å½©å¸¶10éš» é•·åº¦64
        for (var subIdx = 0; subIdx < 10; subIdx++) {
          var x = this.util.idx2AZ(i * 15 + 3 + subIdx % 5);
          var y = subIdx > 4 ? 68 : 2;
          var srid = sheet[x + y];
          if (srid == null)
            continue;
          var ary = [];
          for (var ii = 0; ii < 64; ii++) {
            var y = subIdx > 4 ? (ii + 69) : (ii + 3);
            var rIdx = sheet[x + y];
            if (rIdx != null) {
              ary.push(rIdx);
            }
          }
          // ADDæ¨¡å¼
          var y = subIdx > 4 ? 133 : 67;
          if (sheet[x + y]) {
            var modeStrs = sheet[x + y].split('.');
            var mode = modeStrs[0];
            if (mode == "ADD") {
              // åŠ å¹¾æ¬¡
              var addc = modeStrs[1] ? parseInt(modeStrs[1]) : 1;
              var tmp = ary.slice();
              for (var addi = 1; addi < addc; addi++) {
                ary = ary.concat(tmp.slice());
              }
              for (var ri = 0; ri < reelLen; ri++) {
                ary.push(ri);
              }
            }
            // SUBæ¨¡å¼
            else if (mode == "SUB") {
              var tmp = {};
              var ignores = {};
              for (var ai = 0; ai < ary.length; ai++) {
                ignores[ary[ai]] = true;
              }
              ary = [];
              for (var ri = 0; ri < reelLen; ri++) {
                if (!ignores[ri]) {
                  ary.push(ri);
                }
              }
            }
          }

          if (ary.length > 0) {
            ridMap[srid] = rid;
            shortStrips[srid] = ary;
          }
        }

        // ä¸­å½©å¸¶5éš» é•·åº¦128
        for (var subIdx = 0; subIdx < 5; subIdx++) {
          var x = this.util.idx2AZ(i * 15 + 3 + subIdx);
          var srid = sheet[x + 134];
          if (srid == null)
            continue;
          var ary = [];
          for (var ii = 0; ii < 128; ii++) {
            var y = 135 + ii;
            var rIdx = sheet[x + y];
            if (rIdx != null) {
              ary.push(rIdx);
            }
          }
          // ADDæ¨¡å¼
          if (sheet[x + 263]) {
            var modeStrs = sheet[x + 263].split('.');
            var mode = modeStrs[0];
            var modeArgs = modeStrs[1];
            if (mode == "ADD") {
              // åŠ å¹¾æ¬¡
              var addc = modeStrs[1] ? parseInt(modeStrs[1]) : 1;
              var tmp = ary.slice();
              for (var addi = 1; addi < addc; addi++) {
                ary = ary.concat(tmp.slice());
              }
              for (var ri = 0; ri < reelLen; ri++) {
                ary.push(ri);
              }
            }
            // SUBæ¨¡å¼
            else if (mode == "SUB") {
              var tmp = {};
              var ignores = {};
              for (var ai = 0; ai < ary.length; ai++) {
                ignores[ary[ai]] = true;
              }
              ary = [];
              for (var ri = 0; ri < reelLen; ri++) {
                if (!ignores[ri]) {
                  ary.push(ri);
                }
              }
            }
          }

          if (ary.length > 0) {
            ridMap[srid] = rid;
            shortStrips[srid] = ary;
          }
        }
      }
    });
    result.strips = strips;
    result.shortStrips = shortStrips;
    result.startStrips = startStrips;
    return result;
  }

  /**
   *
   *
   * @param {Object} sheets
   * @memberof Plate
   */
  parseFeature(sheets) { }

  /**
   *
   *
   * @param {Object} sheets
   * @param {Object} config
   * @return {Object} 
   * @memberof Plate
   */
  parseMainPlate(sheets, config) {

    const sheet = sheets.Main;
    const result = {};
    const stripsMode = config.stripsMode ?? 1;
    let s1key = {};
    let s1 = [];
    for (let i = 0; i < 20; i++) {
      let count = sheet['B' + (3 + i)];
      if (count > 0 || count == 'x') {
        s1 = this.util.appendAry(s1, i, count);
        s1key[i] = true;
      }
    }
    s1 = this.util.resizeSticksAry(s1);
    result.s1 = s1;

    // å½©å¸¶ç±¤(20) = ç‹€æ…‹ç±¤[x]
    var s2 = {};
    result.s2 = s2;

    // å½©å¸¶åˆ—è¡¨ [å½©å¸¶ç±¤]
    var c2 = {};
    result.reels = c2;

    // é‡æŠ½æ¢ä»¶
    result.respin = {};

    for (var i = 0; i < 21; i++) {
      if (i != 20 && !s1key[i])
        continue;
      result.respin[i] = {};
      // å½©å¸¶æ¡¶ç±¤æ•¸
      var reelsBucketStrips = [];
      // å½©å¸¶æ¡¶åˆ—è¡¨
      var reelsBucket = {};

      for (var ii = 0; ii < 20; ii++) {
        var xidx = 5 + 8 * i;
        let respinidx = 5 + 10 * i;
        var x = this.util.idx2AZ(xidx);

        var count = sheet[x + (3 + ii)];

        if ((!count || count == 0)) {
          continue;
        }
        reelsBucketStrips = this.util.appendAry(reelsBucketStrips, ii, count);

        // å½©å¸¶
        let reels = [];

        // äº”è¼ª
        var y = (3 + ii);
        for (var iii = 0; iii < 6; iii++) {
          x = this.util.idx2AZ(xidx + iii + 1);
          var rid = sheet[x + y];
          if (!rid) {
            break;
          }
          if (rid) {
            if (stripsMode == 1) {
              if (iii == 5) {
                var args = rid.toString().split(',');
                reels = reels.concat(args);
              }
              else {
                reels[iii] = rid.toString();
              }
            } else if (stripsMode == 0) {
              rid = rid.toString().replace(/\s+/g, "");
              let ary = rid.split(',');
              if (ary.length == 1) {
                ary = [];
                for (let iiii = 0; iiii < config.window.height; iiii++) {
                  ary[iiii] = rid;
                }
              }
              reels[iii] = ary;
            }
          }
        }
        // ä¸»éŠæˆ²é‡æŠ½
        if (sheets.MainRespin != null) {
          var flag = sheets.MainRespin[this.util.idx2AZ(respinidx - 1) + y];

          if (flag == true || flag == 'true' || flag == 'TRUE' || flag == 1) {
            var max = sheets.MainRespin[this.util.idx2AZ(respinidx + 0) + y];
            var maxProb = sheets.MainRespin[this.util.idx2AZ(respinidx + 1) + y];
            var min = sheets.MainRespin[this.util.idx2AZ(respinidx + 2) + y];
            var minProb = sheets.MainRespin[this.util.idx2AZ(respinidx + 3) + y];
            var comboMin = sheets.MainRespin[this.util.idx2AZ(respinidx + 4) + y];
            var comboMinProb = sheets.MainRespin[this.util.idx2AZ(respinidx + 5) + y];
            var comboMax = sheets.MainRespin[this.util.idx2AZ(respinidx + 6) + y];
            var comboMaxProb = sheets.MainRespin[this.util.idx2AZ(respinidx + 7) + y];
            result.respin[i][ii] = [max, maxProb, min, minProb, comboMin, comboMinProb, comboMax, comboMaxProb];
          }
          else {
            result.respin[i][ii] = null;
          }
        }

        if (reels.length >= 5) {
          reelsBucket[ii] = reels;
        }
      }

      reelsBucketStrips = this.util.resizeSticksAry(reelsBucketStrips);

      if (reelsBucketStrips.length > 0) {
        c2[i] = reelsBucket;
        s2[i] = reelsBucketStrips;
      }
    }

    return result;
  }

  /**
   *
   *
   * @param {Object} sheets
   * @memberof Plate
   */
  parseFreePlate(sheets, config) {

    const stripsMode = config.stripsMode ?? 1;

    const freeState = {
      '0': [],
      '1': [],
      '2': [],
      '3': [],
    };
    const multipleRangeMap = {};
    let sheet = sheets.Free;
    let result = {};

    for (let x = 0; x < 4; x++) {
      const idx2AZ = this.util.idx2AZ(x + 1);
      for (let y = 0; y < 5; y++) {
        const z = y + 28;
        freeState[x] = this.util.appendAry(freeState[x], y, sheet[idx2AZ + z]);
      }
      freeState[x] = this.util.resizeSticksAry(freeState[x]);
    }
  
    for (let i = 0; i < 5; i++) {
      const y = i + 28;
      multipleRangeMap[i] = {
        min: Number(sheet[`F${y}`]),
        minChance: Number(sheet[`G${y}`]),
        max: Number(sheet[`H${y}`]),
        maxChance: Number(sheet[`I${y}`]),
      }
    }

    result.freeState = freeState;
    result.multipleRangeMap = multipleRangeMap;

    let s1key = {};
    result.s1 = [];
    result.respin = {};
    // ç‹€æ…‹ç±¤ (20x5)
    for (let ii = 0; ii < 5; ii++) {
      let s1 = [];
      let x = this.util.idx2AZ(1 + ii);
      for (let i = 0; i < 20; i++) {
        let count = sheet[x + (3 + i)];
        if (count > 0) {
          s1 = this.util.appendAry(s1, i, count);
          s1key[i] = true;
        }
      }
      s1 = this.util.resizeSticksAry(s1);
      result.s1.push(s1);
    }

    // å½©å¸¶ç±¤(20) = ç‹€æ…‹ç±¤[x]
    let s2 = {};
    result.s2 = s2;

    // å½©å¸¶åˆ—è¡¨ [å½©å¸¶ç±¤]
    let c2 = {};
    result.reels = c2;

    // æ©«çš„21å€‹ç‹€æ…‹ (æœ€å¾Œä¸€å€‹æ˜¯å¼·é–‹ReTrigger)
    for (let i = 0; i < 21; i++) {
      if (i != 20 && !s1key[i])
        continue;
      // å½©å¸¶æ¡¶ç±¤æ•¸
      result.respin[i] = {};
      let reelsBucketStrips = [];
      // å½©å¸¶æ¡¶åˆ—è¡¨
      let reelsBucket = {};

      for (let ii = 0; ii < 20; ii++) {
        let xidx = 11 + 8 * i;
        let respinidx = 5 + 10 * i;
        let x = this.util.idx2AZ(xidx);
        let y = (3 + ii);
        let count = sheet[x + y];

        if ((!count || count == 0))
          continue;
        reelsBucketStrips = this.util.appendAry(reelsBucketStrips, ii, count);

        // å½©å¸¶
        let reels = [];

        // äº”è¼ª
        for (let iii = 0; iii < 6; iii++) {
          x = this.util.idx2AZ(xidx + iii + 1);
          let rid = sheet[x + y];
          if (!rid) {
            break;
          }
          if (rid) {
            if (stripsMode == 1) {
              if (iii == 5) {
                var args = rid.toString().split(',');
                reels = reels.concat(args);
              }
              else {
                reels[iii] = rid.toString();
              }
            } else if (stripsMode == 0) {
              rid = rid.toString().replace(/\s+/g, "");
              let ary = rid.split(',');
              if (ary.length == 1) {
                ary = [];
                for (let iiii = 0; iiii < config.window.height; iiii++) {
                  ary[iiii] = rid;
                }
              }
              reels[iii] = ary;
            }
          }
        }

        // å…è²»éŠæˆ²é‡æŠ½
        if (sheets.FreeRespin != null) {
          let flag = sheets.FreeRespin[this.util.idx2AZ(respinidx - 1) + y];
          if (flag == true || flag == 'true' || flag == 'TRUE' || flag == 1) {
            let max = sheets.FreeRespin[this.util.idx2AZ(respinidx) + y];
            let maxProb = sheets.FreeRespin[this.util.idx2AZ(respinidx + 1) + y];
            let min = sheets.FreeRespin[this.util.idx2AZ(respinidx + 2) + y];
            let minProb = sheets.FreeRespin[this.util.idx2AZ(respinidx + 3) + y];
            let minCombo = sheets.FreeRespin[this.util.idx2AZ(respinidx + 4) + y];
            let minComboProb = sheets.FreeRespin[this.util.idx2AZ(respinidx + 5) + y];
            let maxCombo = sheets.FreeRespin[this.util.idx2AZ(respinidx + 6) + y];
            let maxComboProb = sheets.FreeRespin[this.util.idx2AZ(respinidx + 7) + y];
            result.respin[i][ii] = [max, maxProb, min, minProb, minCombo, minComboProb, maxCombo, maxComboProb];
          }
          else {
            result.respin[i][ii] = null;
          }
        }

        if (reels.length >= 5) {
          reelsBucket[ii] = reels;
        }
      }

      reelsBucketStrips = this.util.resizeSticksAry(reelsBucketStrips);

      if (reelsBucketStrips.length > 0) {
        c2[i] = reelsBucket;
        s2[i] = reelsBucketStrips;
      }
    };
    return result;
  }

  parsePlateMaxWin(sheets, config) {

    const maxWin = sheets.MaxWin['B3'];
    const maxWinFlag = sheets.MaxWin['C3'] === 'TRUE' || sheets.MaxWin['C3'] === true || sheets.MaxWin['C3'] === 'true';
    config.plateMaxWin = maxWin;
    config.plateMaxWinFlag = maxWinFlag;
  }
}
module.exports = Plate
--- END OF FILE: electron\rand-core\parser\game\parser-plate.js ---

--- START OF FILE: electron\rand-core\parser\game\parser.js ---
class Parser {

  constructor() {
    this.util = require('../util');
  }

  parser() {

    throw new Error('Method parser() must be implemented');
  };

  parseFeature() {

    throw new Error('Method parseFeature() must be implemented');
  };

  loadTableSticky(colRange, rowRange, obj, featureSheet) {
    // è§£æ colRange
    const [colStartCell, colEndCell] = colRange.split('-');
    const colStartMatch = colStartCell.match(/^([A-Z]+)(\d+)$/i);
    const colEndMatch = colEndCell.match(/^([A-Z]+)(\d+)$/i);
    const colStartAZ = colStartMatch[1];
    const colStartNum = parseInt(colStartMatch[2], 10);
    const colEndAZ = colEndMatch[1];

    const colStart = this.util.az2Idx(colStartAZ);
    const colEnd = this.util.az2Idx(colEndAZ);

    // è§£æ rowRange
    const [rowStartCell, rowEndCell] = rowRange.split('-');
    const rowStartMatch = rowStartCell.match(/^([A-Z]+)(\d+)$/i);
    const rowEndMatch = rowEndCell.match(/^([A-Z]+)(\d+)$/i);
    const rowKey = rowStartMatch[1];
    const rowStartNum = parseInt(rowStartMatch[2], 10);
    const rowEndNum = parseInt(rowEndMatch[2], 10);

    for (let i = colStart; i <= colEnd; i++) {
      const colAZ = this.util.idx2AZ(i);
      obj[featureSheet[`${colAZ}${colStartNum}`]] = [];
      for (let x = rowStartNum; x <= rowEndNum; x++) {
        this.util.appendAry(
          obj[featureSheet[`${colAZ}${colStartNum}`]],
          featureSheet[`${rowKey}${x}`],
          featureSheet[`${colAZ}${x}`]
        );
      }
      obj[featureSheet[`${colAZ}${colStartNum}`]] = this.util.resizeSticksAry(obj[featureSheet[`${colAZ}${colStartNum}`]]);
    }
  }

  loadTableValue(colRange, rowRange, obj, featureSheet) {
    // è§£æ colRange
    const [colStartCell, colEndCell] = colRange.split('-');
    const colStartMatch = colStartCell.match(/^([A-Z]+)(\d+)$/i);
    const colEndMatch = colEndCell.match(/^([A-Z]+)(\d+)$/i);
    const colStartAZ = colStartMatch[1];
    const colStartNum = parseInt(colStartMatch[2], 10);
    const colEndAZ = colEndMatch[1];

    const colStart = this.util.az2Idx(colStartAZ);
    const colEnd = this.util.az2Idx(colEndAZ);

    // è§£æ rowRange
    const [rowStartCell, rowEndCell] = rowRange.split('-');
    const rowStartMatch = rowStartCell.match(/^([A-Z]+)(\d+)$/i);
    const rowEndMatch = rowEndCell.match(/^([A-Z]+)(\d+)$/i);
    const rowKey = rowStartMatch[1];
    const rowStartNum = parseInt(rowStartMatch[2], 10);
    const rowEndNum = parseInt(rowEndMatch[2], 10);

    for (let i = colStart; i <= colEnd; i++) {
      const colAZ = this.util.idx2AZ(i);
      obj[featureSheet[`${colAZ}${colStartNum}`]] = {};
      for (let x = rowStartNum; x <= rowEndNum; x++) {
        obj[featureSheet[`${colAZ}${colStartNum}`]][featureSheet[`${rowKey}${x}`]] = featureSheet[`${colAZ}${x}`];
      }
    }
  }
}
module.exports = Parser
--- END OF FILE: electron\rand-core\parser\game\parser.js ---

--- START OF FILE: electron\rand-core\parser\game\paylines.json ---
{
  "cols": 5,
  "rows": 3,
  "paylines": [
    [
      1,
      1,
      1,
      1,
      1
    ],
    [
      0,
      0,
      0,
      0,
      0
    ],
    [
      2,
      2,
      2,
      2,
      2
    ],
    [
      0,
      1,
      2,
      1,
      0
    ],
    [
      2,
      1,
      0,
      1,
      2
    ],
    [
      0,
      0,
      1,
      0,
      0
    ],
    [
      2,
      2,
      1,
      2,
      2
    ],
    [
      1,
      0,
      0,
      0,
      1
    ],
    [
      1,
      2,
      2,
      2,
      1
    ],
    [
      1,
      0,
      1,
      0,
      1
    ],
    [
      1,
      2,
      1,
      2,
      1
    ],
    [
      0,
      1,
      0,
      1,
      0
    ],
    [
      2,
      1,
      2,
      1,
      2
    ],
    [
      1,
      1,
      0,
      1,
      1
    ],
    [
      1,
      1,
      2,
      1,
      1
    ],
    [
      0,
      1,
      1,
      1,
      0
    ],
    [
      2,
      1,
      1,
      1,
      2
    ],
    [
      0,
      1,
      2,
      2,
      2
    ],
    [
      2,
      1,
      0,
      0,
      0
    ],
    [
      0,
      2,
      0,
      2,
      0
    ],
    [
      2,
      0,
      2,
      0,
      2
    ],
    [
      1,
      0,
      2,
      0,
      1
    ],
    [
      1,
      2,
      0,
      2,
      1
    ],
    [
      0,
      0,
      1,
      2,
      2
    ],
    [
      2,
      2,
      1,
      0,
      0
    ]
  ]
}
--- END OF FILE: electron\rand-core\parser\game\paylines.json ---

--- START OF FILE: electron\rand-core\parser\parserService.js ---
// folder structure:
// â””â”€â”€ config-game
//      â”œâ”€â”€ define.xls              (å…±ç”¨)
//      â”œâ”€â”€ plate.xls               (ä¸€èˆ¬)
//      â”œâ”€â”€ mainPrize               (æŒ‡å®šæ´¾å½©)
//      |   â””â”€â”€ {times}.xls         (å€æ•¸)
//      â””â”€â”€ itemPrize               (è³¼è²·å…è²»éŠæˆ²)
//          â””â”€â”€ {type}/{times}.xls (å€æ•¸)

const path = require("path");
// ğŸ”¥ ä¿®æ”¹ 1ï¼šæ›æˆ xlsx (SheetJS)ï¼Œå®ƒå°ä¸­æ–‡æ”¯æ´æœ€å¥½
const XLS = require('xlsx');
const fs = require('fs');
const plateParse = require('./game/parser-plate');
const defineParse = require('./game/parser-define');
const tableLoader = require('./tableLoader');
const hasher = require('folder-hash');
class ParserService {

  constructor() {
    this.util = require('./util');
    this.saveDir = path.join(__dirname, "../config/");
    this.tableLoader = new tableLoader(this.util);
    this.plateParse = new plateParse(this.tableLoader);
    this.defineParse = new defineParse();
    this.randMode = [];
    this.CONFIG_TYPE = {
      DEFAULT: 0,
      MAINPRIZE: 2,
      ITEM: 3
    };
  }

  parse(xlsRoot = path.join(__dirname, '../../../xls')) {

    const gameXlsPath = path.join(xlsRoot, 'config-game');
    const defineSheets = this.loadXls(path.join(gameXlsPath, 'define.xls'));

    const defineConfig = this.defineParse.parser(defineSheets);
    this.randMode = defineConfig.randMode;

    const plateConfig = {
      default: {},
    };
    const mainPrizes = [];
    const itemPrizes = {};
    const items = {};

    for (const key of this.randMode) {
      if (!plateConfig[key]) {
        plateConfig[key] = {};
      }
    }

    let plateInfos = this.findFilesAndConvertSync(`${gameXlsPath}/default`, 'plate_');
    plateConfig.default.high = this.loadPlate(`${gameXlsPath}/default`, '/' + plateInfos[0].fileName, defineConfig);
    plateConfig.default.high.rtp = plateInfos[0].decimalValue;
    plateConfig.default.high.name = plateInfos[0].fileName;
    plateConfig.default.high.type = this.CONFIG_TYPE.DEFAULT;
    plateConfig.default.high.randMode = 'default';

    if (plateInfos[1] !== undefined) {
      plateConfig.default.low = this.loadPlate(`${gameXlsPath}/default`, '/' + plateInfos[1].fileName, defineConfig);
      plateConfig.default.low.rtp = plateInfos[1].decimalValue;
      plateConfig.default.low.name = plateInfos[1].fileName;
      plateConfig.default.low.type = this.CONFIG_TYPE.DEFAULT;
      plateConfig.default.low.randMode = 'default';
    }

    for (const key of this.randMode) {
      if (fs.existsSync(path.join(gameXlsPath, key))) {
        let plateInfos = this.findFilesAndConvertSync(`${gameXlsPath}/${key}`, 'plate_');
        plateConfig[key].high = this.loadPlate(`${gameXlsPath}/${key}`, '/' + plateInfos[0].fileName, defineConfig);
        plateConfig[key].high.rtp = plateInfos[0].decimalValue;
        plateConfig[key].high.name = plateInfos[0].fileName;
        plateConfig[key].high.type = this.CONFIG_TYPE.DEFAULT;
        plateConfig[key].high.randMode = key;

        if (plateInfos[1] !== undefined) {
          plateConfig[key].low = this.loadPlate(`${gameXlsPath}/${key}`, '/' + plateInfos[1].fileName, defineConfig);
          plateConfig[key].low.rtp = plateInfos[1].decimalValue;
          plateConfig[key].low.name = plateInfos[1].fileName;
          plateConfig[key].low.type = this.CONFIG_TYPE.DEFAULT;
          plateConfig[key].low.randMode = key;
        }
      }
    }

    if (fs.existsSync(path.join(gameXlsPath, 'mainPrize'))) {
      fs.readdirSync(path.join(gameXlsPath, `mainPrize/`)).forEach(file => {
        let conf = this.loadPlate(gameXlsPath, `/mainPrize/${file}`, defineConfig);
        if (!conf) {
          return;
        }
        let score = file.split(".")[0];
        conf.name = "mp_" + score;
        conf.type = this.CONFIG_TYPE.MAINPRIZE;
        conf.id = 0;
        let mp = {
          'score': score,
          'config': conf
        };
        mainPrizes.push(mp);
      });

      mainPrizes.sort(function (a, b) {
        return b.score - a.score;
      });

      for (let i = 0; i < mainPrizes.length; i++) {
        mainPrizes[i].config.id = i;
      }
    }

    if (fs.existsSync(path.join(gameXlsPath, 'itemPrize'))) {
      fs.readdirSync(path.join(gameXlsPath, 'itemPrize')).forEach(folder => {
        let p = gameXlsPath + '/itemPrize/' + folder;
        if (fs.lstatSync(p).isDirectory()) {
          let items = [];
          fs.readdirSync(p).forEach(file => {
            let conf = this.loadPlate(gameXlsPath, '/itemPrize/' + folder + '/' + file, defineConfig);
            if (!conf)
              return;
            let score = file.split(".")[0];
            conf.name = "item_" + score;
            conf.type = this.CONFIG_TYPE.ITEM;
            items.push({
              'score': score,
              'config': conf
            });
          });
          if (items.length > 0) {
            items.sort(function (a, b) {
              return b.score - a.score;
            });
            for (let i = 0; i < items.length; i++) {
              items[i].config.id = folder + i;
            }
            itemPrizes[folder] = items;
          }
        }
      });
    }

    if (fs.existsSync(path.join(gameXlsPath, 'item.xls'))) {
      let itemConf = this.loadXls(path.join(gameXlsPath, 'item.xls'));
      for (let i = 0; i < 3; i++) {
        let y = i + 3;
        let type = itemConf.List["A" + y];

        if (type !== undefined) {
          let name = itemConf.List["B" + y];
          // åƒ¹æ ¼
          let rate = itemConf.List["C" + y];
          // éŠæˆ²æ¬¡æ•¸
          let count = itemConf.List["D" + y];

          let sticks = {};
          sticks.high = [];
          this.util.appendAry(sticks.high, 0, itemConf.List["E" + y]);
          this.util.appendAry(sticks.high, 1, itemConf.List["I" + y]);
          this.util.appendAry(sticks.high, 2, itemConf.List["M" + y]);
          this.util.resizeSticksAry(sticks.high);

          sticks.low = [];
          this.util.appendAry(sticks.low, 0, itemConf.List["F" + y]);
          this.util.appendAry(sticks.low, 1, itemConf.List["J" + y]);
          this.util.appendAry(sticks.low, 2, itemConf.List["N" + y]);
          this.util.resizeSticksAry(sticks.low);

          // é˜²å‘† é˜²æ­¢ä¸»ç‰Œæ²’è¨­å®š
          if (itemPrizes[type] != null) {
            items[type] = {
              'type': type,
              'name': name,
              'rate': rate,
              'count': count,
              'states': [
                { 'min': itemConf.List["G" + y], 'max': itemConf.List["H" + y] },
                { 'min': itemConf.List["K" + y], 'max': itemConf.List["L" + y] },
                { 'min': itemConf.List["O" + y], 'max': itemConf.List["P" + y] }
              ],
              'stateSticks': sticks
            };
          }
          else {
            console.log("item no set", "type:", type);
          }
        }
      }
    }

    // æ¸…ç†èˆŠçš„ JSON æª”æ¡ˆï¼ˆä¿ç•™ spec.jsonï¼‰
    try {
      const files = fs.readdirSync(this.saveDir);
      files.forEach(file => {
        if (file.endsWith('.json') && file !== 'spec.json') {
          fs.unlinkSync(path.join(this.saveDir, file));
          console.log(`Delete: ${file}`);
        }
      });
    } catch (err) {
      console.error('Error:', err);
    }

    // å¯«å…¥è¨­å®šæª”

    for (const key in plateConfig) {
      fs.writeFileSync(this.saveDir + `${key}.json`, JSON.stringify(plateConfig[key]));
    }

    fs.writeFileSync(this.saveDir + 'define.json', JSON.stringify(defineConfig));
    if (Object.keys(items).length > 0) {
      fs.writeFileSync(this.saveDir + 'items.json', JSON.stringify(items));
    }
    if (Object.keys(itemPrizes).length > 0) {
      fs.writeFileSync(this.saveDir + 'itemPrize.json', JSON.stringify(itemPrizes));
    }
    if (Object.keys(mainPrizes).length > 0) {
      fs.writeFileSync(this.saveDir + 'mainPrize.json', JSON.stringify(mainPrizes));
    }

    let options = {
      excludes: ['.DS_Store', 'hash.txt'],
      match: { basename: true, path: true }
    };
    const distPath = this.saveDir;
    hasher.hashElement(distPath, options).then(function (hash) {
      console.log(hash.toString());
      fs.writeFileSync(distPath + "/hash.txt", hash.hash);
    });
  }

  loadXls(path) {
    let xls = undefined;
    try {
      // ğŸ”¥ ä¿®æ”¹ 2ï¼šxlsx é è¨­å°±æœƒè‡ªå‹•è™•ç†ç·¨ç¢¼ï¼Œä¸ç”¨æ“”å¿ƒäº‚ç¢¼
      xls = XLS.readFile(path, {});
    }
    catch (e) {
      console.log("loadXls", path, e);
    }
    const result = {};
    for (let i in xls.Sheets) {
      result[i] = {};
      const sheet = xls.Sheets[i];
      for (let ii in sheet) {
        // ğŸ”¥ ä¿®æ”¹ 3ï¼šéæ¿¾æ‰ xlsx ç”¢ç”Ÿçš„ metadata (ä»¥ ! é–‹é ­çš„å±¬æ€§ï¼Œå¦‚ !ref, !margins)
        // é€™æ¨£å¯ä»¥é¿å… undefined çš„éŒ¯èª¤
        if (ii[0] === '!') continue;

        // xlsx çš„è³‡æ–™çµæ§‹æ˜¯ { v: 'value', t: 'type' }ï¼Œæ‰€ä»¥å– .v
        if (sheet[ii] && sheet[ii].v !== undefined && sheet[ii].v !== '')
          result[i][ii] = sheet[ii].v;
      }
    }
    return result;
  }

  loadPlate(gameXlsPath, path, defineConfig) {

    if (!/.*\/\w+\.xls$/.test(path)) {
      console.log("invalid path", path);
      return null;
    }

    const sheets = this.loadXls(gameXlsPath + path);
    const plateConfig = this.plateParse.parser(defineConfig, sheets);

    return plateConfig;
  }

  findFilesAndConvertSync(directoryPath, prefix) {

    const regex = new RegExp(`${prefix}(\\d+)\\.xls$`);
    let result = [];
    try {
      const files = fs.readdirSync(directoryPath);
      files.forEach((file) => {
        const match = file.match(regex);
        if (match) {
          const n = match[1];
          const decimalValue = (parseFloat(n) / 1000).toFixed(3);
          const fileName = file;
          result.push({ fileName, decimalValue });
        }
      });
    }
    catch (err) {
      console.error('Unable to scan directory:', err);
    }
    // æŒ‰ decimalValue é™åºæ’åº
    result.sort((a, b) => b.decimalValue - a.decimalValue);
    return result;
  }
}
module.exports = new ParserService();
--- END OF FILE: electron\rand-core\parser\parserService.js ---

--- START OF FILE: electron\rand-core\parser\tableLoader.js ---
class TableLoader {
  constructor(util) {
    this.util = util;
  }
  /* --------------------------------- private -------------------------------- */
  _generateSticks(array) {
    const result = [];
    for (let index = 0; index < array.length; index++) {
      this.util.appendAry(result, index, array[index]);
    }
    this.util.resizeSticksAry(result);
    return result;
  }
  _loadRows(sheet, columnIndexAZ, rowStartIndex, rowStopIndex, isWeightAble) {
    let result = [];
    for (let row_index = rowStartIndex; row_index <= rowStopIndex; row_index++) {
      const coord = columnIndexAZ + row_index;
      const data = sheet[coord];
      if (data !== undefined) {
        result.push(data);
      }
    }
    if (isWeightAble === true) {
      result = this._generateSticks(result);
    }
    return result;
  }
  _loadData(sheet, StartString, StopString, isWeightAble, returnAsArray) {
    const result = returnAsArray ? [] : {};
    const [columnStartString, rowStartIndex] = StartString.split('-');
    const columnStartIndex = this.util.az2Idx(columnStartString);
    const [columnStopString, rowStopIndex] = StopString.split('-');
    const columnStopIndex = this.util.az2Idx(columnStopString);

    if (returnAsArray === false) {
      for (let column_index = columnStartIndex, index = 0; column_index <= columnStopIndex; column_index++, index++) {
        const columnIndexAZ = this.util.idx2AZ(column_index);
        const data = this._loadRows(sheet, columnIndexAZ, parseInt(rowStartIndex), parseInt(rowStopIndex), isWeightAble);
        result[`${index}`] = data;
      }
    }
    else {
      for (let column_index = columnStartIndex; column_index <= columnStopIndex; column_index++) {
        const columnIndexAZ = this.util.idx2AZ(column_index);
        const coord = columnIndexAZ + rowStartIndex;
        result.push(sheet[coord]);
      }
    }

    return result;
  }
  /* --------------------------------- public --------------------------------- */
  loadValues(sheet, StartString, StopString) {
    return this._loadData(sheet, StartString, StopString, false, false);
  }
  loadSticks(sheet, StartString, StopString) {
    return this._loadData(sheet, StartString, StopString, true, false);
  }
  loadLevels(sheet, StartString, StopString) {
    return this._loadData(sheet, StartString, StopString, false, true);
  }
}
module.exports = TableLoader;
--- END OF FILE: electron\rand-core\parser\tableLoader.js ---

--- START OF FILE: electron\rand-core\parser\util.js ---
var util = {};
module.exports = util;

// 0:A, 25:Z, 26:AA, 27:AB ...
util.idx2AZ = function (i) {
  return (i >= 26 ? util.idx2AZ((i / 26 >> 0) - 1) : '') + 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'[i % 26 >> 0];
};

// A:0, B:1 Z:25 AA:26
util.az2Idx = function (val) {
  var base = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', i, j, result = 0;
  for (i = 0, j = val.length - 1; i < val.length; i += 1, j -= 1) {
    result += Math.pow(base.length, j) * (base.indexOf(val[i]) + 1);
  }
  result -= 1;
  return result;
};

// symbol id convert to code
util.s2id = function (s) {
  return 'ABCDEFGHIJWSXYZ'.indexOf(s);
};

// get char * len
util.getStrs = function (str, count) {
  var strs = '';
  for (var i = 0; i < count; i++) {
    strs += str;
  }
  return strs;
};

util.appendAry = function (ary, obj, count) {
  for (var i = 0; i < count; i++)
    ary.push(obj);
  return ary;
};

// minimize sticks
util.resizeSticks = function (sticks) {
  if (sticks == '')
    return sticks;

  var counts = [];
  var count_idx_map = {};
  for (var i in sticks) {
    var stick = sticks[i].toString();
    if (count_idx_map[stick] == null) {
      counts.push(0);
      count_idx_map[stick] = counts.length - 1;
    }
    counts[count_idx_map[stick]]++;
  }

  sticks = '';

  var gcd = util.getGCD.apply(null, counts);
  for (var i in count_idx_map) {
    var stick = i;
    var count = counts[count_idx_map[i]] / gcd;
    sticks += util.getStrs(stick, count);
  }
  return sticks;
};

util.resizeSticksAry = function (sticks) {
  if (sticks.length == 0)
    return sticks;


  var counts = [];
  var names = [];
  for (var i in sticks) {
    var stick = sticks[i];
    var idx = names.indexOf(stick);
    if (idx == -1) {
      idx = counts.length;
      counts[idx] = 0;
      names[idx] = stick;
    }
    counts[idx]++;
  }

  sticks.splice(0, sticks.length);

  var gcd = util.getGCD.apply(null, counts);
  for (var i in names) {
    var name = names[i];
    var count = counts[i] / gcd;
    sticks = util.appendAry(sticks, name, count);
  }
  return sticks;
};

if ('function' !== typeof Array.prototype.reduce) {
  Array.prototype.reduce = function (callback, opt_initialValue) {
    'use strict';
    if (null === this || 'undefined' === typeof this) {
      // At the moment all modern browsers, that support strict mode, have
      // native implementation of Array.prototype.reduce. For instance, IE8
      // does not support strict mode, so this check is actually useless.
      throw new TypeError(
        'Array.prototype.reduce called on null or undefined');
    }
    if ('function' !== typeof callback) {
      throw new TypeError(callback + ' is not a function');
    }
    var index, value,
      length = this.length >>> 0,
      isValueSet = false;
    if (1 < arguments.length) {
      value = opt_initialValue;
      isValueSet = true;
    }
    for (index = 0; length > index; ++index) {
      if (this.hasOwnProperty(index)) {
        if (isValueSet) {
          value = callback(value, this[index], index, this);
        }
        else {
          value = this[index];
          isValueSet = true;
        }
      }
    }
    if (!isValueSet) {
      throw new TypeError('Reduce of empty array with no initial value');
    }
    return value;
  };
};

var gcd = function (a, b) {
  if (b === 0) return a;
  return gcd(b, a % b);
};

// å–æœ€å¤§å…¬å› æ•¸
util.getGCD = function () {
  var args = Array.prototype.slice.call(arguments);
  return args.reduce(gcd);
};

// æ’åˆ—çµ„åˆ
util.combination = function (arr, num) {
  var r = [];
  (function f(t, a, n) {
    if (n == 0) return r.push(t);
    for (var i = 0, l = a.length; i <= l - n; i++) {
      f(t.concat(a[i]), a.slice(i + 1), n - 1);
    }
  })([], arr, num);
  return r;
};

util.clone = function (obj) {
  return JSON.parse(JSON.stringify(obj));
};

util.aryEqual = function (a, b) {
  if (Array.isArray(a) == false || Array.isArray(b) == false)
    return false;
  if (a.length != b.length)
    return false;
  var len = a.length;
  for (var i = 0; i < len; i++) {
    if (a[i] != b[i])
      return false;
  }
  return true;
};

--- END OF FILE: electron\rand-core\parser\util.js ---

--- START OF FILE: electron\setting\config.json ---

{
  "components": [
    {
      "model": "BaseStatModule",
      "view": "BaseReportView"
    },
    {
      "model": "LineStatModule",
      "view": "LineReportView"
    },
    {
      "model": "ScatterStatModule",
      "view": "ScatterReportView"
    }
  ]
}
--- END OF FILE: electron\setting\config.json ---

--- START OF FILE: electron\simulation\stats\BaseStatModule.ts ---
// electron/simulation/stats/BaseStatModule.ts
import { IStatModule, FullStatReport, RangeBucket } from '../types';

const GAPS = [0, 0.01, 0.25, 0.5, 1, 2, 3, 5, 6, 8, 10, 15, 20, 30, 50, 100, 200, 300, 500, 1000, 2000, 3000, 4000, 5000, 10000, 99999999];

export class BaseStatModule implements IStatModule {
  name = 'base';
  private define: any = null;
  private data: FullStatReport;
  private gaps = GAPS;
  private exitInfo = { exitStart: 1000, exitEnd: 0, exitMaxWin: 2000 };

  constructor() {
    this.data = this.createEmptyData();
  }

  public setExitInfo(info: any) {
    if (info) this.exitInfo = { ...this.exitInfo, ...info };
  }

  public init(define: any) {
    this.define = define;
  }

  // ğŸ”¥ é€™è£¡çš„ totalWin æ˜¯ Manager ç®—å¥½å‚³é€²ä¾†çš„
  onSpin(bet: number, totalWin: number, rawResult: any, lineCount: number) {
    const result = rawResult.game;
    if (!result) return;

    // 1. åŸºç¤æ•¸æ“šç´¯åŠ  (å°æ‡‰èˆŠç‰ˆ onSpin é–‹é ­)
    this.data.spinTimes++;
    this.data.totalBet += bet;
    this.data.totalWin += totalWin; // Manager ç®—å¥½çš„å€¼ (å·²ç¶“æ˜¯é‡‘é¡)

    // 2. çµ±è¨ˆ Total Secret & WinList (å°æ‡‰ #countTotalMultiplierRange)
    // èˆŠç‰ˆæ˜¯å­˜å…¥åˆ—è¡¨ä¸¦è¨ˆç®—å€é–“
    this.data.totalWinList.push(totalWin);
    this.countRange(this.data.totalSecret, totalWin, bet);

    // 3. çµ±è¨ˆ Main (å°æ‡‰ #countBaseMultiplierRange & #countTotalWinAndHitRate)
    let mainWin = 0;
    if (Array.isArray(result.mainWin)) {
      mainWin = (result.mainWin[0] / lineCount + result.mainWin[1]) * bet;
    }
    this.data.baseWin += mainWin;
    if (mainWin > 0) this.data.mainWinTimes++;
    this.countRange(this.data.mainSecret, mainWin, bet);

    // 4. çµ±è¨ˆ Free (å°æ‡‰ if (result.free))
    if (result.free) {
      const freeResult = result.free;

      if (freeResult.results) {
        // å°æ‡‰ #countFreeTimesAndFreeSpinTimes
        // æ³¨æ„ï¼šèˆŠç‰ˆ freeTimes æ˜¯æŒ‡è§¸ç™¼æ¬¡æ•¸ï¼Œé€™è£¡å‡è¨­ result.free å­˜åœ¨å³è§¸ç™¼
        // å¦‚æœè¦æ›´ç²¾ç¢ºï¼Œå¯èƒ½è¦åˆ¤æ–· isTriggered
        if (freeResult.times > 0 || freeResult.results.length > 0) {
          this.data.freeTimes++;
        }
        this.data.freeSpinTimes += freeResult.results.length;

        // å°æ‡‰ #countFreeMultiplierRange (æ•´å ´ Free Game ç¸½åˆ†)
        let fWin = 0;
        if (Array.isArray(freeResult.win)) {
          fWin = (freeResult.win[0] / lineCount + freeResult.win[1]) * bet;
        }
        this.data.freeSpinWin += fWin;
        this.countRange(this.data.freeSumSecret, fWin, bet);

        // å°æ‡‰ #countEveryFreeSpinMultiplierRange (æ¯ä¸€è½‰)
        freeResult.results.forEach((res: any) => {
          let singleWin = 0;
          if (res.prizes && Array.isArray(res.prizes.win)) {
            singleWin = (res.prizes.win[0] / lineCount + res.prizes.win[1]) * bet;
          }
          if (singleWin > 0) this.data.freeWinTimes++;
          this.countRange(this.data.freeSecret, singleWin, bet);
        });
      }
    }
  }

  // å°æ‡‰èˆŠç‰ˆ countRange é‚è¼¯
  private countRange(secretArray: RangeBucket[], val: number, bet: number) {
    const multiplier = bet > 0 ? val / bet : 0;
    for (let i = 0; i < secretArray.length; i++) {
      if (multiplier >= secretArray[i].min && multiplier < secretArray[i].max) {
        secretArray[i].count++;
        break;
      }
    }
  }

  // --- Merge ---
  merge(other: FullStatReport) {
    this.data.spinTimes += other.spinTimes;
    this.data.totalBet += other.totalBet;
    this.data.totalWin += other.totalWin;
    this.data.mainWinTimes += other.mainWinTimes;
    this.data.freeTimes += other.freeTimes;
    this.data.freeSpinTimes += other.freeSpinTimes;
    this.data.freeWinTimes += other.freeWinTimes;
    this.data.baseWin += other.baseWin;
    this.data.freeSpinWin += other.freeSpinWin;

    // ä½¿ç”¨è¿´åœˆ Push é¿å…å¡æ­»
    if (other.totalWinList && other.totalWinList.length > 0) {
      for (let i = 0; i < other.totalWinList.length; i++) {
        this.data.totalWinList.push(other.totalWinList[i]);
      }
    }

    this.mergeSecret(this.data.totalSecret, other.totalSecret);
    this.mergeSecret(this.data.mainSecret, other.mainSecret);
    this.mergeSecret(this.data.freeSecret, other.freeSecret);
    this.mergeSecret(this.data.freeSumSecret, other.freeSumSecret);
  }

  private mergeSecret(target: RangeBucket[], source: RangeBucket[]) {
    for (let i = 0; i < target.length; i++) {
      target[i].count += source[i].count;
    }
  }

  getData() { return this.data; }

  // --- Get Result (å°æ‡‰ getEndReport) ---
  getResult(rate?: number) {

    const { totalWinList, spinTimes, totalBet, totalWin } = this.data;
    const multiplier = rate || 1;
    // 1. MaxWin & RTP
    let max = 0;
    for (let w of totalWinList) { if (w > max) max = w; }

    const realTotalBet = totalBet * multiplier;
    const finalRTP = realTotalBet > 0 ? totalWin / realTotalBet : 0;

    const avgBaseBet = spinTimes > 0 ? totalBet / spinTimes : 1;
    const avgRealBet = avgBaseBet * multiplier;

    let sumSqDiff = 0;
    for (let i = 0; i < totalWinList.length; i++) {
      const val = (totalWinList[i] / avgRealBet) - finalRTP;
      sumSqDiff += val * val;
    }
    const SD = spinTimes > 0 ? Math.sqrt(sumSqDiff / spinTimes) : 0;
    const CI_RANGE = spinTimes > 0 ? (1.96 * SD / Math.sqrt(spinTimes)) : 0;
    const CI_MAX = finalRTP + CI_RANGE;
    const CI_MIN = finalRTP - CI_RANGE;

    // 3. Exit Rate
    const exitResult = this.countExitRate(totalWinList, rate || 1);

    // 4. Format Secret (Avg & Reverse)
    const formatSecret = (secret: RangeBucket[], denominator: number) => {
      const copy = secret.map(s => ({ ...s }));
      // èˆŠç‰ˆé‚è¼¯ï¼šåè½‰é™£åˆ—
      copy.reverse();
      // è¨ˆç®—å¹³å‡
      copy.forEach((item) => {
        item.avg = (item.count > 0 && denominator > 0) ? denominator / item.count : 0;
      });
      return copy;
    };

    return {
      // Raw Data
      bet: avgRealBet, // å¹³å‡æ³¨é¡
      totalBet :realTotalBet,
      totalWin,
      spinTimes,
      mainWinTimes: this.data.mainWinTimes,
      mainWin: this.data.baseWin,
      freeWin: this.data.freeSpinWin,
      freeTimes: this.data.freeTimes,
      freeSpinTimes: this.data.freeSpinTimes,
      freeWinTimes: this.data.freeWinTimes,

      // Secrets
      totalSecret: formatSecret(this.data.totalSecret, spinTimes),
      mainSecret: formatSecret(this.data.mainSecret, spinTimes),
      freeSecret: formatSecret(this.data.freeSecret, this.data.freeSpinTimes),
      freeSumSecret: formatSecret(this.data.freeSumSecret, this.data.freeTimes),

      // Analysis
      exitRateTest: exitResult,
      SD: SD,
      CI_RANGE: CI_RANGE,
      CI_MAX: CI_MAX,
      CI_MIN: CI_MIN,
      MaxWin: max,
      rtp: (finalRTP * 100).toFixed(4) + '%' // é¡å¤–æä¾›ä¸€å€‹æ ¼å¼åŒ–å¥½çš„å­—ä¸²
    };
  }

  private countExitRate(winList: number[], rate: number) {
    const { exitStart, exitEnd, exitMaxWin } = this.exitInfo;
    let botGold = exitStart * rate;
    let botTotalGold = 0;
    let botCount = 0;
    let exitWinCount = 0;
    let botWinSpin = 0;
    let botSpin = 0;

    const len = winList.length;
    for (let i = 0; i < len; i++) {
      botSpin++;
      const win = winList[i];

      if (win >= (exitMaxWin * rate)) {
        botGold -= (1 * rate); // æ‰£é™¤æˆæœ¬ (èˆŠé‚è¼¯)
      } else {
        botGold += win - (1 * rate);
      }

      if (botGold < (1 * rate) || (botGold >= exitEnd * rate && exitEnd > 0)) { // é€™è£¡ä¾ç…§ä½ çš„éœ€æ±‚èª¿æ•´
        if (botGold >= (exitStart * rate)) {
          exitWinCount++;
          botWinSpin += botSpin;
        }
        botTotalGold += botGold;
        botCount++;
        botGold = exitStart * rate;
        botSpin = 0;
      }
    }

    return {
      rate: botCount > 0 ? (botTotalGold / botCount / (exitStart * rate)) : 0,
      players: botCount,
      winPlayers: exitWinCount,
      totalGold: botTotalGold,
      winSpins: botWinSpin
    };
  }

  private createEmptyData(): FullStatReport {
    return {
      totalWinList: [],
      spinTimes: 0, totalBet: 0, totalWin: 0,
      totalSecret: this.createSecret(),
      mainSecret: this.createSecret(),
      freeSecret: this.createSecret(),
      freeSumSecret: this.createSecret(),
      mainWinTimes: 0, freeTimes: 0, freeSpinTimes: 0, freeWinTimes: 0,
      baseWin: 0, freeSpinWin: 0
    };
  }

  private createSecret(): RangeBucket[] {
    const secret: RangeBucket[] = [];
    for (let i = 0; i < this.gaps.length - 1; i++) {
      secret.push({
        min: this.gaps[i],
        max: this.gaps[i + 1],
        count: 0,
        avg: 0
      });
    }
    return secret;
  }
}
--- END OF FILE: electron\simulation\stats\BaseStatModule.ts ---

--- START OF FILE: electron\simulation\stats\registry.ts ---
// electron/simulation/stats/registry.ts
import { BaseStatModule } from './BaseStatModule';
// å‡è¨­ä½ å·²ç¶“å¯«å¥½äº† LineStatModule (å¦‚æœé‚„æ²’ï¼Œä¸‹é¢æœƒæ•™ä½ å¯«)
// import { LineStatModule } from './LineStatModule'; 

// ğŸ”¥ é€™è£¡å°±æ˜¯ä½ çš„ã€Œæ¨¡çµ„å·¥å» ã€
export const StatModuleRegistry: Record<string, any> = {
  'BaseStatModule': BaseStatModule,
  // 'LineStatModule': LineStatModule, // æœªä¾†æŠŠè¨»è§£æ‰“é–‹
  // 'ScatterStatModule': ScatterStatModule,
};
--- END OF FILE: electron\simulation\stats\registry.ts ---

--- START OF FILE: electron\simulation\stats\StatsManager.ts ---
// electron/simulation/stats/StatsManager.ts
import { IStatModule } from '../types';
import { StatModuleRegistry } from './registry';

export class StatsManager {
  private modules: IStatModule[] = [];
  public exitInfo: any;

  constructor(config: any) {
    // ... (åˆå§‹åŒ–é‚è¼¯ä¿æŒä¸è®Šï¼Œè¼‰å…¥ BaseStatModule ç­‰) ...
    // é€™è£¡çœç•¥é‡è¤‡ä»£ç¢¼ï¼Œè«‹ä¿ç•™åŸæœ¬çš„ constructor é‚è¼¯
    const BaseClass = StatModuleRegistry['BaseStatModule'];
    const base = new BaseClass();
    if (config.exitInfo) {
      (base as any).setExitInfo(config.exitInfo);
      this.exitInfo = config.exitInfo;
    }
    this.modules.push(base);

    if (config.components && Array.isArray(config.components)) {
      for (const comp of config.components) {
        if (comp.model === 'BaseStatModule') continue;
        const ModuleClass = StatModuleRegistry[comp.model];
        if (ModuleClass) {
          const instance = new ModuleClass(comp.args || {});
          this.modules.push(instance);
        }
      }
    }
  }

  public init(define: any) {
    this.modules.forEach(m => m.init(define));
  }

  // ğŸ”¥ğŸ”¥ğŸ”¥ æ ¸å¿ƒä¿®æ”¹ï¼šçµ±ä¸€è¨ˆç®—ï¼Œåˆ†ç™¼æ•¸æ“š ğŸ”¥ğŸ”¥ğŸ”¥
  public onSpin(bet: number, rawResult: any, lineCount: number) {
    // 1. åœ¨é€™è£¡çµ±ä¸€è¨ˆç®—æœ¬å±€ç¸½è´åˆ† (Total Win)
    let totalWin = 0;
    const game = rawResult.game;

    if (game) {
      // Main Win
      if (Array.isArray(game.totalWin)) {
        totalWin += (game.totalWin[0] / lineCount + game.totalWin[1]) * bet;
      }
    }

    // 2. å°‡ç®—å¥½çš„ bet, totalWin å‚³çµ¦æ‰€æœ‰ Module
    this.modules.forEach(m => m.onSpin(bet, totalWin, rawResult, lineCount));
  }

  public merge(fullReport: any) {
    this.modules.forEach(m => {
      if (fullReport[m.name]) {
        m.merge(fullReport[m.name]);
      }
    });
  }

  public getRawData() {
    const raw: any = {};
    this.modules.forEach(m => {
      raw[m.name] = m.getData();
    });
    return raw;
  }

  public getFinalReport(rate?: number) {
    const report: any = {};
    this.modules.forEach(m => {
      report[m.name] = m.getResult(rate);
    });
    return report;
  }
}
--- END OF FILE: electron\simulation\stats\StatsManager.ts ---

--- START OF FILE: electron\simulation\types.ts ---
// electron/simulation/types.ts

// æ¨¡æ“¬è¨­å®š
export interface SimulationConfig {
  spinCount: number;
  betAmount: number;
  betLevel: number;
  lines: number;
  buyFeatureType: number;
  targetRTP: number;
  randMode: string;
  targetPrizeType?: number;
  targetWinLimit?: number;
  lineCount: number;
  // å­˜æ´»ç‡æ¸¬è©¦åƒæ•¸
  exitInfo?: {
    exitStart: number;  // åˆå§‹é‡‘é¡
    exitEnd: number;    // åœæé» (é€šå¸¸æ˜¯ 0)
    exitMaxWin: number; // åœåˆ©é»
  }
  components?: Array<{ model: string; view: string; args?: any }>;
}

// åˆ†ä½ˆå€é–“å–®å…ƒ
export interface RangeBucket {
  min: number;
  max: number;
  count: number;
  avg: number; // é¡¯ç¤ºç”¨
}

// çµ±è¨ˆå–®å…ƒ
export interface StatUnit {
  spinCount: number;
  totalBet: number;
  totalWin: number;
  winCount: number;
  maxWin: number;
  distribution: RangeBucket[];
}

// å­˜æ´»ç‡æ¸¬è©¦çµæœ
export interface ExitRateResult {
  rate: number;       // å›å ±ç‡
  players: number;    // ç¸½æ¨¡æ“¬äººæ•¸
  winPlayers: number; // ç²åˆ©äººæ•¸
  totalGold: number;  // æ©Ÿå™¨ç¸½ç²åˆ©
  winSpins: number;   // ç²åˆ©å ´æ¬¡
}

export interface FullStatReport {
  // åŸºç¤æ•¸æ“š
  totalWinList: number[];
  spinTimes: number;
  totalBet: number;
  totalWin: number; // æ•¸å€¼

  // å››ç¨®åˆ†ä½ˆæ•¸æ“š (å°æ‡‰èˆŠç‰ˆ Secret)
  totalSecret: RangeBucket[];   // All
  mainSecret: RangeBucket[];    // Main Game
  freeSecret: RangeBucket[];    // Free Game (Every Spin)
  freeSumSecret: RangeBucket[]; // Free Game (Total)

  // æ¬¡æ•¸çµ±è¨ˆ
  mainWinTimes: number;
  freeTimes: number;
  freeSpinTimes: number;
  freeWinTimes: number;

  // é‡‘é¡çµ±è¨ˆ
  baseWin: number;      // Main Win Amount
  freeSpinWin: number;  // Free Win Amount

  // å­˜æ´»ç‡èˆ‡çµ±è¨ˆæŒ‡æ¨™ (getResult æ™‚è¨ˆç®—)
  exitRateTest?: ExitRateResult;
  SD?: number;
  CI_RANGE?: number;
  CI_MAX?: number;
  CI_MIN?: number;
  MaxWin?: number;
  rtp?: string;
}

export interface IStatModule {
  name: string;
  init(define: any): void;
  onSpin(bet: number, totalWin: number, rawResult: any, lineCount: number): void;
  merge(otherData: any): void;
  getResult(rate?: number): any;
  getData(): any;
}

export interface WorkerInput {
  workerId: number;
  config: SimulationConfig;
  chunkSize: number;
  randCorePath: string;
}

export interface WorkerProgress {
  type: 'progress';
  workerId: number;
  processed: number;
  percent: number;
}
--- END OF FILE: electron\simulation\types.ts ---

--- START OF FILE: electron\simulation\worker.ts ---
// electron/simulation/worker.ts
import workerpool from 'workerpool';
import { createRequire } from 'module';
import { WorkerInput, WorkerProgress } from './types';
// ğŸ”¥ å¼•ç”¨ Managerï¼Œè€Œä¸æ˜¯ Module
import { StatsManager } from './stats/StatsManager';

const require = createRequire(import.meta.url);

const runSimulation = (input: WorkerInput): any => {

  const { config, randCorePath, chunkSize, workerId } = input;
  const statsManager = new StatsManager({
    ...config,
    exitInfo: input.config.exitInfo
  });

  // 2. åˆå§‹åŒ– Core
  let randInstance: any = null;
  let define: any = null;
  try {
    const RandCore = require(randCorePath);
    const core = RandCore();
    if (!core || !core.rand) throw new Error("Core Init Failed");
    randInstance = core.rand;
    define = randInstance.define;
  } catch (e: any) {
    throw new Error(`[Worker ${workerId}] Core Init Failed: ${e.message}`);
  }

  // 3. æº–å‚™åƒæ•¸
  const betInfo = {
    betlv: config.betLevel,
    lineBet: config.betAmount / config.lineCount, // å‡è¨­
    lineSelect: config.lineCount,
    buyFeatureType: config.buyFeatureType
  };
  const sysState = {
    targetRTP: config.targetRTP,
    randMode: config.randMode,
    targetPrizeType: config.targetPrizeType,
    targetWinLimit: config.targetWinLimit
  };

  const progressStep = Math.max(Math.floor(chunkSize / 20), 1000);
  statsManager.init(define);
  // 4. é–‹å§‹è¿´åœˆ
  for (let i = 0; i < chunkSize; i++) {
    try {
      const result = randInstance.getSpinResult(betInfo, sysState, {}, {});

      // ğŸ”¥ é—œéµï¼šåªå‘¼å« Managerï¼Œä¸æ¶‰åŠé‚è¼¯
      statsManager.onSpin(config.betAmount, result, config.lineCount);

      // å›å ±é€²åº¦
      if ((i + 1) % progressStep === 0) {
        workerpool.workerEmit({
          type: 'progress',
          workerId,
          processed: i + 1,
          percent: ((i + 1) / chunkSize) * 100
        } as WorkerProgress);
      }

    } catch (e) {
      if (i === 0) console.error(`[Worker ${workerId}] Spin Error:`, e);
    }
  }

  // 5. å›å‚³ Raw Data
  return {
    type: 'result',
    workerId,
    // ä½¿ç”¨ getRawData å–å¾—æ‰€æœ‰æ¨¡çµ„çš„è³‡æ–™
    stats: statsManager.getRawData()
  };
};

workerpool.worker({
  runSimulation
});
--- END OF FILE: electron\simulation\worker.ts ---
