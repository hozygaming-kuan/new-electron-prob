const fs = require('fs');
const path = require('path');
const { spawn, execSync } = require('child_process');

// --- 1. è¨­å®šè·¯å¾‘ ---
const CONFIG_PATH = path.join(__dirname, 'electron/setting/config.json');

// å¾Œç«¯è·¯å¾‘
const BACKEND_DIR = path.join(__dirname, 'electron/simulation/stats');
const BACKEND_REGISTRY = path.join(BACKEND_DIR, 'registry.ts');

// å‰ç«¯è·¯å¾‘
const FRONTEND_DIR = path.join(__dirname, 'src/components/reports');
const FRONTEND_REGISTRY = path.join(FRONTEND_DIR, 'index.ts');

// æ¨¡æ¿è·¯å¾‘
const TPL_DIR = path.join(__dirname, 'templates');
const TPL_BACKEND = path.join(TPL_DIR, 'backend.ts.hbs');
const TPL_FRONTEND = path.join(TPL_DIR, 'frontend.vue.hbs');

// --- Helper Functions ---

function getOldContent(path) {
  if (fs.existsSync(path)) return fs.readFileSync(path, 'utf-8');
  return '';
}

// è®€å–ä¸¦æ›¿æ›æ¨¡æ¿
function renderTemplate(tplPath, data) {
  if (!fs.existsSync(tplPath)) {
    // å¦‚æœæ‰¾ä¸åˆ°å¤–éƒ¨æ¨¡æ¿ï¼Œé€™è£¡å¯ä»¥æä¾›ä¸€å€‹é è¨­çš„ fallback å­—ä¸²ï¼Œæˆ–è€…å ±éŒ¯
    console.error(`âŒ Template not found: ${tplPath}`);
    return '';
  }
  let content = fs.readFileSync(tplPath, 'utf-8');
  // ç°¡å–®çš„æ›¿æ›é‚è¼¯
  for (const [key, value] of Object.entries(data)) {
    content = content.replaceAll(`{{${key}}}`, value);
  }
  return content;
}

// --- 3. ä¸»è¦é‚è¼¯ ---

function generate() {
  if (!fs.existsSync(CONFIG_PATH)) {
    console.error('âŒ Config file not found!');
    return;
  }

  let config;
  try {
    config = JSON.parse(fs.readFileSync(CONFIG_PATH, 'utf-8'));
  } catch (e) {
    console.error('âŒ JSON Parse Error. Waiting for fix...');
    return;
  }

  const components = config.components || [];

  const backendImports = [];
  const backendKeys = [];
  const frontendImports = [];
  const frontendKeys = [];

  // ç¢ºä¿ç›®æ¨™è³‡æ–™å¤¾å­˜åœ¨
  if (!fs.existsSync(BACKEND_DIR)) fs.mkdirSync(BACKEND_DIR, { recursive: true });
  if (!fs.existsSync(FRONTEND_DIR)) fs.mkdirSync(FRONTEND_DIR, { recursive: true });

  components.forEach(comp => {
    const { model, view } = comp;

    // --- Backend Model è™•ç† ---
    if (model) {
      const filePath = path.join(BACKEND_DIR, `${model}.ts`);

      // åªæœ‰æª”æ¡ˆä¸å­˜åœ¨æ™‚æ‰å»ºç«‹ (é¿å…è¦†è“‹ä½ å¯«å¥½çš„é‚è¼¯)
      if (!fs.existsSync(filePath)) {
        const content = renderTemplate(TPL_BACKEND, {
          name: model,
          keyName: model.replace("StatModule", "").toLowerCase()
        });
        if (content) {
          fs.writeFileSync(filePath, content);
          console.log(`âœ¨ [Auto-Gen] Created Backend: ${model}.ts`);
        }
      }

      // ç„¡è«–æª”æ¡ˆæ˜¯å¦æ–°å»ºç«‹ï¼Œåªè¦ config æœ‰ï¼Œå°±åŠ å…¥ Registry
      backendImports.push(`import { ${model} } from './${model}';`);
      backendKeys.push(`  '${model}': ${model},`);
    }

    // --- Frontend View è™•ç† ---
    if (view) {
      const filePath = path.join(FRONTEND_DIR, `${view}.vue`);

      if (!fs.existsSync(filePath)) {
        const content = renderTemplate(TPL_FRONTEND, { name: view });
        if (content) {
          fs.writeFileSync(filePath, content);
          console.log(`âœ¨ [Auto-Gen] Created View: ${view}.vue`);
        }
      }

      frontendImports.push(`import ${view} from './${view}.vue';`);
      frontendKeys.push(`  '${view}': ${view},`);
    }
  });

  // æ›´æ–° Registry
  // æ³¨æ„ï¼šé€™è£¡åªæœƒåŒ…å«ä¸Šæ–¹ components è¿´åœˆä¸­æœ‰è·‘åˆ°çš„æ¨¡çµ„
  // å¦‚æœ config.json ç§»é™¤äº†æŸå€‹æ¨¡çµ„ï¼Œå®ƒå°±ä¸æœƒå‡ºç¾åœ¨é€™è£¡ï¼Œè‡ªç„¶å°±å®Œæˆäº†ã€Œå¾è¨»å†Šè¡¨ç§»é™¤ã€
  const backendContent = `// Auto-generated by scaffold.js\n${backendImports.join('\n')}\n\nexport const StatModuleRegistry: Record<string, any> = {\n${backendKeys.join('\n')}\n};\n`;
  const frontendContent = `// Auto-generated by scaffold.js\n${frontendImports.join('\n')}\n\nexport const ReportViewRegistry: Record<string, any> = {\n${frontendKeys.join('\n')}\n};\n`;

  if (getOldContent(BACKEND_REGISTRY) !== backendContent) {
    fs.writeFileSync(BACKEND_REGISTRY, backendContent);
    console.log('âœ… Updated Backend Registry');
  }
  if (getOldContent(FRONTEND_REGISTRY) !== frontendContent) {
    fs.writeFileSync(FRONTEND_REGISTRY, frontendContent);
    console.log('âœ… Updated Frontend Registry');
  }
}

// --- 4. åŸ·è¡Œå…¥å£ ---

generate();

if (process.argv.includes('--watch')) {
  console.log('ğŸ‘€ [Scaffold] Watching config.json for changes...');

  fs.watchFile(CONFIG_PATH, { interval: 1000 }, (curr, prev) => {
    if (curr.mtime !== prev.mtime) {
      console.log('ğŸ”„ Config changed, checking modules...');
      generate();
    }
  });

  console.log('ğŸš€ Starting Vite...');

  const viteProcess = spawn('npm', ['run', 'dev:vite'], { stdio: 'inherit', shell: true });

  // ğŸ”¥ğŸ”¥ğŸ”¥ æ–°å¢ï¼šå»ºç«‹ç”Ÿå‘½é€±æœŸä¿¡è™Ÿæª” ğŸ”¥ğŸ”¥ğŸ”¥
  const SESSION_FILE = path.join(__dirname, '.dev-session');
  fs.writeFileSync(SESSION_FILE, 'running'); // å»ºç«‹æª”æ¡ˆ

  let isCleaning = false;

  const cleanup = () => {
    if (isCleaning) return;
    isCleaning = true;

    console.log('ğŸ›‘ Cleaning up processes...');

    // ç§»é™¤ä¿¡è™Ÿæª” (å¦‚æœæ˜¯æŒ‰ Ctrl+C çµæŸçš„)
    if (fs.existsSync(SESSION_FILE)) {
      try { fs.unlinkSync(SESSION_FILE); } catch (e) { }
    }

    if (viteProcess.pid) {
      if (process.platform === 'win32') {
        try {
          // å¼·åˆ¶æ®ºæ­»é€²ç¨‹æ¨¹
          execSync(`taskkill /pid ${viteProcess.pid} /f /t`, { stdio: 'ignore' });
        } catch (e) { }
      } else {
        try { process.kill(-viteProcess.pid); } catch (e) { }
      }
    }

    process.exit(0);
  };

  // ğŸ”¥ğŸ”¥ğŸ”¥ æ–°å¢ï¼šæ¯ç§’æª¢æŸ¥ä¿¡è™Ÿæª”æ˜¯å¦å­˜åœ¨ ğŸ”¥ğŸ”¥ğŸ”¥
  // å¦‚æœæª”æ¡ˆè¢« Electron åˆªé™¤äº†ï¼Œé€™è£¡å°±æœƒè§¸ç™¼ cleanup
  const sessionWatcher = setInterval(() => {
    if (!fs.existsSync(SESSION_FILE)) {
      console.log('ğŸ”Œ Detected app closure, shutting down terminal...');
      clearInterval(sessionWatcher);
      cleanup();
    }
  }, 1000);

  process.on('SIGINT', cleanup);
  process.on('SIGTERM', cleanup);
  process.on('exit', cleanup);
}